
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Analyseur Grammatical</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Roboto:wght@300;400;500&display=swap');
    
    :root {
      --primary-color: #5D5CDE;
      --primary-glow: rgba(93, 92, 222, 0.6);
      --secondary-color: #00e5ff;
      --secondary-glow: rgba(0, 229, 255, 0.5);
      --accent-color: #ff00e5;
      --accent-glow: rgba(255, 0, 229, 0.5);
      --success-color: #00ff9d;
      --success-glow: rgba(0, 255, 157, 0.5);
      --warning-color: #ffae00;
      --warning-glow: rgba(255, 174, 0, 0.5);
      --danger-color: #ff3471;
      --danger-glow: rgba(255, 52, 113, 0.5);
      --dark-bg: #121223;
      --card-bg: #1a1a2e;
      --input-bg: #0c0c1d;
      --border-color: #2a2a4a;
      --text-color: #e0e0ff;
      --text-secondary: #9090c0;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Roboto', sans-serif;
      background-color: var(--dark-bg);
      color: var(--text-color);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow-x: hidden;
    }
    
    /* Background animated gradient */
    body::before {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at 20% 30%, rgba(93, 92, 222, 0.1) 0%, transparent 30%),
                  radial-gradient(circle at 80% 20%, rgba(0, 229, 255, 0.07) 0%, transparent 30%),
                  radial-gradient(circle at 30% 70%, rgba(255, 0, 229, 0.07) 0%, transparent 25%);
      z-index: -1;
      pointer-events: none;
    }
    
    .container {
      max-width: 900px;
      width: 100%;
      margin: 0 auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      flex-grow: 1;
    }
    
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 0;
      margin-bottom: 1.5rem;
      border-bottom: 1px solid var(--border-color);
    }
    
    h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.75rem;
      color: var(--primary-color);
      text-shadow: 0 0 10px var(--primary-glow);
      letter-spacing: 1px;
    }
    
    .system-status {
      display: flex;
      align-items: center;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }
    
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: var(--success-color);
      box-shadow: 0 0 10px var(--success-glow);
      margin-right: 0.5rem;
      position: relative;
    }
    
    .status-dot::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background-color: var(--success-color);
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 0.8;
      }
      50% {
        transform: scale(2.5);
        opacity: 0;
      }
      100% {
        transform: scale(1);
        opacity: 0;
      }
    }
    
    /* Chat container */
    .chat-container {
      flex-grow: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      margin-bottom: 1rem;
      padding-right: 0.5rem;
      max-height: calc(100vh - 170px);
    }
    
    /* Scrollbar */
    .chat-container::-webkit-scrollbar {
      width: 6px;
    }
    
    .chat-container::-webkit-scrollbar-track {
      background: var(--input-bg);
      border-radius: 10px;
    }
    
    .chat-container::-webkit-scrollbar-thumb {
      background: var(--primary-color);
      border-radius: 10px;
    }
    
    /* Chat messages */
    .message {
      max-width: 85%;
      margin-bottom: 1rem;
      padding: 0.75rem 1rem;
      border-radius: 1.2rem;
      position: relative;
      animation: fadeIn 0.3s ease-out;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .message.user {
      align-self: flex-end;
      background-color: var(--primary-color);
      box-shadow: 0 0 15px var(--primary-glow);
      border-bottom-right-radius: 0.3rem;
    }
    
    .message.bot {
      align-self: flex-start;
      background-color: var(--card-bg);
      border: 1px solid var(--border-color);
      border-bottom-left-radius: 0.3rem;
    }
    
    .message-content {
      font-size: 0.95rem;
      line-height: 1.4;
    }
    
    .message-time {
      font-size: 0.7rem;
      color: rgba(255, 255, 255, 0.6);
      margin-top: 0.25rem;
      text-align: right;
    }
    
    /* Word tags in bot messages */
    .word-tag {
      display: inline-block;
      padding: 0.1rem 0.4rem;
      border-radius: 0.5rem;
      margin: 0.15rem 0.1rem;
      font-size: 0.9rem;
      font-weight: 500;
      transition: transform 0.2s, box-shadow 0.2s;
      cursor: help;
    }
    
    .word-tag:hover {
      transform: translateY(-2px);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
    }
    
    /* Codes couleur pour chaque cat√©gorie grammaticale */
    .pronoun {
      background-color: #ff517a;
      color: #fff;
    }
    
    .verb {
      background-color: #00a3ff;
      color: #fff;
    }
    
    .determiner {
      background-color: #9c6bff;
      color: #fff;
    }
    
    .noun {
      background-color: #00cf86;
      color: #fff;
    }
    
    .adjective {
      background-color: #ffb347;
      color: #fff;
    }
    
    .adverb {
      background-color: #7c83ff;
      color: #fff;
    }
    
    .preposition {
      background-color: #ff65b2;
      color: #fff;
    }
    
    .conjunction {
      background-color: #c17aff;
      color: #fff;
    }
    
    .negation {
      background-color: #ff5252;
      color: #fff;
    }
    
    .interjection {
      background-color: #ffcc29;
      color: #333;
    }
    
    /* Tooltip */
    .tooltip {
      position: relative;
    }
    
    .tooltip .tooltip-text {
      visibility: hidden;
      position: absolute;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(10, 10, 25, 0.95);
      color: var(--text-color);
      text-align: center;
      border-radius: 6px;
      padding: 0.5rem;
      width: max-content;
      max-width: 200px;
      font-size: 0.75rem;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.3s;
      border: 1px solid var(--border-color);
      pointer-events: none;
    }
    
    .tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }
    
    /* Category list */
    .category-list {
      background-color: var(--card-bg);
      border-radius: 0.6rem;
      padding: 1rem;
      margin-top: 0.5rem;
      border: 1px solid var(--border-color);
    }
    
    .category-header {
      display: flex;
      align-items: center;
      margin-bottom: 0.75rem;
    }
    
    .category-badge {
      padding: 0.3rem 0.6rem;
      border-radius: 0.5rem;
      font-size: 0.75rem;
      font-weight: bold;
      margin-right: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: white;
    }
    
    .pronoun-badge { background-color: #ff517a; }
    .verb-badge { background-color: #00a3ff; }
    .determiner-badge { background-color: #9c6bff; }
    .noun-badge { background-color: #00cf86; }
    .adjective-badge { background-color: #ffb347; }
    .adverb-badge { background-color: #7c83ff; }
    .preposition-badge { background-color: #ff65b2; }
    .conjunction-badge { background-color: #c17aff; }
    .negation-badge { background-color: #ff5252; }
    .interjection-badge { background-color: #ffcc29; color: #333; }
    
    .category-description {
      font-size: 0.8rem;
      color: var(--text-secondary);
    }
    
    .category-content {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }
    
    /* Input area */
    .input-container {
      position: relative;
      margin-top: auto;
    }
    
    .chat-input {
      width: 100%;
      padding: 1rem 3.5rem 1rem 1.2rem;
      border-radius: 16px;
      border: 1px solid var(--border-color);
      background-color: var(--input-bg);
      color: var(--text-color);
      font-size: 1rem;
      outline: none;
      transition: all 0.3s;
      box-shadow: 0 0 20px rgba(93, 92, 222, 0.1);
    }
    
    .chat-input:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px var(--primary-glow);
    }
    
    /* Glow effect for the input */
    .input-glow {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      border-radius: 16px;
      z-index: -1;
    }
    
    .input-container:focus-within .input-glow {
      box-shadow: 0 0 20px var(--primary-glow);
    }
    
    .send-button {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: var(--primary-color);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      transition: all 0.2s;
    }
    
    .send-button:hover {
      background-color: var(--primary-color);
      color: white;
    }
    
    .send-button svg {
      width: 18px;
      height: 18px;
    }
    
    /* Loading animation */
    .typing-indicator {
      display: flex;
      padding: 0.5rem 1rem;
      background-color: var(--card-bg);
      border-radius: 1.2rem;
      border-bottom-left-radius: 0.3rem;
      align-self: flex-start;
      margin-bottom: 1rem;
      width: auto;
    }
    
    .typing-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: var(--text-secondary);
      margin: 0 2px;
      animation: typingBounce 1.4s infinite;
      opacity: 0.6;
    }
    
    .typing-dot:nth-child(1) { animation-delay: 0s; }
    .typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .typing-dot:nth-child(3) { animation-delay: 0.4s; }
    
    @keyframes typingBounce {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-5px); }
    }
    
    /* Loader */
    .loader {
      display: inline-block;
      position: relative;
      width: 50px;
      height: 15px;
    }
    
    .loader-dot {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background-color: var(--primary-color);
      animation: loader-dot 1.2s ease-in-out infinite;
    }
    
    .loader-dot:nth-child(1) {
      left: 0;
      animation-delay: 0s;
    }
    
    .loader-dot:nth-child(2) {
      left: 20px;
      animation-delay: 0.2s;
    }
    
    .loader-dot:nth-child(3) {
      left: 40px;
      animation-delay: 0.4s;
    }
    
    @keyframes loader-dot {
      0%, 100% { 
        transform: scale(0.5);
        opacity: 0.3;
      }
      50% { 
        transform: scale(1.2);
        opacity: 1;
      }
    }
    
    /* Futuristic scanner lines effect */
    .scanner-line {
      position: absolute;
      width: 100%;
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--secondary-color), transparent);
      animation: scan 4s infinite;
      opacity: 0.5;
      pointer-events: none;
    }
    
    @keyframes scan {
      0% {
        top: 0;
        opacity: 0;
      }
      5% {
        opacity: 0.8;
      }
      50% {
        top: 100%;
      }
      95% {
        opacity: 0.8;
      }
      100% {
        top: 0;
        opacity: 0;
      }
    }
    
    /* Responsive design */
    @media (max-width: 768px) {
      .container {
        padding: 0.75rem;
      }
      
      h1 {
        font-size: 1.4rem;
      }
      
      .message {
        max-width: 90%;
        padding: 0.6rem 0.75rem;
      }
      
      .chat-input {
        padding: 0.75rem 3rem 0.75rem 1rem;
      }
    }
    
    @media (max-width: 480px) {
      h1 {
        font-size: 1.1rem;
      }
      
      .system-status {
        font-size: 0.7rem;
      }
      
      .message {
        max-width: 95%;
      }
      
      .word-tag {
        font-size: 0.8rem;
        padding: 0.1rem 0.3rem;
      }
    }
  </style>
</head>
<body>
  <div class="scanner-line"></div>
  
  <div class="container">
    <header>
      <h1>DYNAMIC ANALYZER</h1>
      <div class="system-status">
        <div class="status-dot"></div>
        <span>Syst√®me op√©rationnel</span>
      </div>
    </header>
    
    <div class="chat-container" id="chatContainer">
      <div class="message bot">
        <div class="message-content">
          Bonjour, je suis votre <span class="word-tag adjective tooltip">intelligent<span class="tooltip-text">Adjectif qualificatif</span></span> analyseur grammatical. √âcrivez une phrase en fran√ßais, et je l'analyserai pour vous.
        </div>
        <div class="message-time">Aujourd'hui</div>
      </div>
    </div>
    
    <div class="input-container">
      <div class="input-glow"></div>
      <input type="text" class="chat-input" id="userInput" placeholder="Tapez votre phrase ici..." autocomplete="off">
      <button class="send-button" id="sendButton">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
        </svg>
      </button>
    </div>
  </div>

  <script>
    // Descriptions des cat√©gories grammaticales
    const categoryDescriptions = {
      pronoun: "Les pronoms remplacent g√©n√©ralement un nom ou un groupe nominal.",
      verb: "Les verbes expriment des actions, des √©tats ou des processus.",
      noun: "Les noms d√©signent des personnes, des lieux, des objets ou des concepts.",
      adjective: "Les adjectifs qualifient ou d√©terminent les noms.",
      determiner: "Les d√©terminants pr√©cisent l'identit√© ou la quantit√© du nom qu'ils accompagnent.",
      adverb: "Les adverbes modifient un verbe, un adjectif ou un autre adverbe.",
      preposition: "Les pr√©positions relient des mots ou groupes de mots entre eux.",
      conjunction: "Les conjonctions relient des mots, des propositions ou des phrases.",
      negation: "Les n√©gations sont utilis√©es pour nier une affirmation.",
      interjection: "Les interjections expriment une √©motion ou une r√©action."
    };
    
    // Noms des cat√©gories en fran√ßais
    const categoryNames = {
      pronoun: "Pronom",
      verb: "Verbe",
      noun: "Nom",
      adjective: "Adjectif",
      determiner: "D√©terminant",
      adverb: "Adverbe",
      preposition: "Pr√©position",
      conjunction: "Conjonction",
      negation: "N√©gation",
      interjection: "Interjection"
    };
    
    // Grammaire fran√ßaise : Base de donn√©es linguistique
    const frenchGrammar = {
      // MOTS INVARIABLES
      prepositions: [
        "√†", "apr√®s", "avant", "avec", "chez", "contre", "dans", "de", "depuis", 
        "derri√®re", "d√®s", "devant", "durant", "en", "entre", "envers", "hormis", 
        "hors", "jusque", "malgr√©", "outre", "par", "parmi", "pendant", "pour", 
        "pr√®s", "sans", "sauf", "selon", "sous", "suivant", "sur", "vers", "via"
      ],
      
      conjunctions: {
        coordination: ["et", "mais", "ou", "donc", "or", "ni", "car"],
        subordination: ["que", "quand", "comme", "si", "lorsque", "puisque", "quoique", "parce", "afin", "bien"]
      },
      
      adverbs: [
        "ainsi", "alors", "assez", "aujourd'hui", "aussi", "autant", "autrefois", "beaucoup",
        "bien", "bient√¥t", "certes", "combien", "comment", "davantage", "debout", "dedans",
        "dehors", "d√©j√†", "demain", "encore", "enfin", "ensemble", "ensuite", "environ",
        "fort", "hier", "ici", "jamais", "l√†", "loin", "longtemps", "lors", "maintenant",
        "mal", "mieux", "moins", "parfois", "partout", "peu", "plus", "plusieurs", "plut√¥t",
        "presque", "puis", "quasiment", "quelquefois", "seulement", "si", "souvent", "tant",
        "tant√¥t", "tard", "tellement", "t√¥t", "toujours", "toutefois", "tr√®s", "trop", "vite"
      ],
      
      negations: ["ne", "n'", "pas", "plus", "jamais", "gu√®re", "point", "nullement", "aucunement"],
      
      // PRONOMS
      pronouns: {
        personal: ["je", "j'", "tu", "il", "elle", "on", "nous", "vous", "ils", "elles", 
                 "me", "m'", "te", "t'", "se", "s'", "le", "l'", "la", "les", "lui", "leur", 
                 "moi", "toi", "soi", "eux", "y", "en"],
        
        relative: ["qui", "que", "qu'", "quoi", "dont", "o√π", "lequel", "laquelle", "lesquels", 
                 "lesquelles", "auquel", "auxquels", "auxquelles", "duquel", "desquels", "desquelles"],
        
        demonstrative: ["ce", "c'", "√ßa", "ceci", "cela", "celui", "celle", "ceux", "celles", 
                       "celui-ci", "celle-ci", "ceux-ci", "celles-ci"],
        
        possessive: ["le mien", "la mienne", "les miens", "les miennes", "le tien", "la tienne", 
                    "les tiens", "les tiennes", "le sien", "la sienne", "les siens", "les siennes", 
                    "le n√¥tre", "la n√¥tre", "les n√¥tres", "le v√¥tre", "la v√¥tre", "les v√¥tres", 
                    "le leur", "la leur", "les leurs"],
        
        indefinite: ["aucun", "aucune", "autre", "certains", "certaines", "chacun", "chacune", 
                    "nul", "nulle", "on", "personne", "plusieurs", "quelqu'un", "quelques-uns", 
                    "quelques-unes", "quelque chose", "quiconque", "rien", "tel", "telle", "tout", 
                    "toute", "tous", "toutes"]
      },
      
      // NOMS COMMUNS (une liste basique pour aider √† l'identification)
      nouns: {
        common: [
          "homme", "femme", "enfant", "personne", "gens", "temps", "chose", "ann√©e", "jour", "fois",
          "vie", "moment", "heure", "monde", "fa√ßon", "c√¥t√©", "main", "≈ìil", "pied", "t√™te",
          "corps", "c≈ìur", "esprit", "id√©e", "mot", "question", "raison", "probl√®me", "fait", "cas",
          "pays", "ville", "maison", "rue", "place", "table", "chambre", "bureau", "porte", "fen√™tre",
          "voiture", "train", "avion", "bateau", "v√©lo", "route", "chemin", "voyage", "travail", "√©cole",
          "livre", "histoire", "image", "film", "musique", "chanson", "jeu", "sport", "argent", "prix",
          "eau", "terre", "air", "feu", "soleil", "lune", "√©toile", "ciel", "mer", "montagne",
          "arbre", "fleur", "animal", "chien", "chat", "oiseau", "poisson", "ami", "famille", "parent",
          "p√®re", "m√®re", "fr√®re", "s≈ìur", "fils", "fille", "nom", "pr√©nom", "regard", "sourire",
          "couleur", "lumi√®re", "bruit", "silence", "go√ªt", "odeur", "toucher", "sentiment", "amour", "bonheur",
          "joie", "plaisir", "peine", "douleur", "col√®re", "peur", "r√™ve", "sommeil", "nuit", "matin",
          "journ√©e", "soir", "semaine", "mois", "saison", "printemps", "√©t√©", "automne", "hiver", "exemple",
          "nombre", "moiti√©", "partie", "d√©but", "fin", "suite", "sens", "avis", "besoin", "envie",
          "droit", "loi", "gouvernement", "pr√©sident", "ministre", "pouvoir", "guerre", "paix", "libert√©", "v√©rit√©",
          "cours", "classe", "√©l√®ve", "√©tudiant", "professeur", "docteur", "m√©decin", "client", "patron", "geste",
          "action", "solution", "attention", "int√©r√™t", "choix", "d√©cision", "r√©ponse", "situation", "exp√©rience", "recherche"
        ]
      },
      
      // D√âTERMINANTS
      determiners: {
        articles: {
          definite: ["le", "la", "l'", "les"],
          indefinite: ["un", "une", "des"],
          partitive: ["du", "de la", "de l'", "des"]
        },
        
        possessive: ["mon", "ma", "mes", "ton", "ta", "tes", "son", "sa", "ses", 
                    "notre", "nos", "votre", "vos", "leur", "leurs"],
        
        demonstrative: ["ce", "cet", "cette", "ces"],
        
        interrogative: ["quel", "quels", "quelle", "quelles"],
        
        indefinite: ["aucun", "aucune", "autre", "autres", "certain", "certains", "certaine", 
                    "certaines", "chaque", "diff√©rents", "diff√©rentes", "divers", "diverses", 
                    "maint", "mainte", "maints", "maintes", "m√™me", "m√™mes", "nul", "nulle", "plusieurs", 
                    "quelque", "quelques", "tel", "tels", "telle", "telles", "tout", "tous", "toute", "toutes"]
      },
      
      // VERBES
      verbs: {
        // Auxiliaires complets avec toutes leurs formes
        auxiliaries: {
          avoir: {
            infinitif: "avoir",
            participePresent: "ayant",
            participePass√©: ["eu", "eue", "eus", "eues"],
            indicatifPresent: ["ai", "as", "a", "avons", "avez", "ont"],
            indicatifImparfait: ["avais", "avais", "avait", "avions", "aviez", "avaient"],
            indicatifPasseSimple: ["eus", "eus", "eut", "e√ªmes", "e√ªtes", "eurent"],
            indicatifFuturSimple: ["aurai", "auras", "aura", "aurons", "aurez", "auront"],
            conditionnelPresent: ["aurais", "aurais", "aurait", "aurions", "auriez", "auraient"],
            subjonctifPresent: ["aie", "aies", "ait", "ayons", "ayez", "aient"],
            subjonctifImparfait: ["eusse", "eusses", "e√ªt", "eussions", "eussiez", "eussent"],
            imperatifPresent: ["aie", "ayons", "ayez"]
          },
          
          √™tre: {
            infinitif: "√™tre",
            participePresent: "√©tant",
            participePass√©: ["√©t√©"],
            indicatifPresent: ["suis", "es", "est", "sommes", "√™tes", "sont"],
            indicatifImparfait: ["√©tais", "√©tais", "√©tait", "√©tions", "√©tiez", "√©taient"],
            indicatifPasseSimple: ["fus", "fus", "fut", "f√ªmes", "f√ªtes", "furent"],
            indicatifFuturSimple: ["serai", "seras", "sera", "serons", "serez", "seront"],
            conditionnelPresent: ["serais", "serais", "serait", "serions", "seriez", "seraient"],
            subjonctifPresent: ["sois", "sois", "soit", "soyons", "soyez", "soient"],
            subjonctifImparfait: ["fusse", "fusses", "f√ªt", "fussions", "fussiez", "fussent"],
            imperatifPresent: ["sois", "soyons", "soyez"]
          }
        },
        
        // Verbes fr√©quents
        common: {
          aller: {
            infinitif: "aller",
            participePresent: "allant",
            participePass√©: ["all√©", "all√©e", "all√©s", "all√©es"],
            indicatifPresent: ["vais", "vas", "va", "allons", "allez", "vont"],
            indicatifImparfait: ["allais", "allais", "allait", "allions", "alliez", "allaient"]
          },
          
          faire: {
            infinitif: "faire",
            participePresent: "faisant",
            participePass√©: ["fait", "faite", "faits", "faites"],
            indicatifPresent: ["fais", "fais", "fait", "faisons", "faites", "font"],
            indicatifImparfait: ["faisais", "faisais", "faisait", "faisions", "faisiez", "faisaient"]
          },
          
          voir: {
            infinitif: "voir",
            participePresent: "voyant",
            participePass√©: ["vu", "vue", "vus", "vues"],
            indicatifPresent: ["vois", "vois", "voit", "voyons", "voyez", "voient"],
            indicatifImparfait: ["voyais", "voyais", "voyait", "voyions", "voyiez", "voyaient"]
          },
          
          // Ajout de verbes fr√©quents pour am√©liorer la d√©tection
          oser: {
            infinitif: "oser",
            participePresent: "osant",
            indicatifPresent: ["ose", "oses", "ose", "osons", "osez", "osent"]
          },
          
          viser: {
            infinitif: "viser",
            participePresent: "visant",
            indicatifPresent: ["vise", "vises", "vise", "visons", "visez", "visent"]
          },
          
          prendre: {
            infinitif: "prendre",
            participePresent: "prenant",
            indicatifPresent: ["prends", "prends", "prend", "prenons", "prenez", "prennent"]
          },
          
          pouvoir: {
            infinitif: "pouvoir",
            participePresent: "pouvant",
            indicatifPresent: ["peux", "peux", "peut", "pouvons", "pouvez", "peuvent"]
          },
          
          vouloir: {
            infinitif: "vouloir",
            participePresent: "voulant",
            indicatifPresent: ["veux", "veux", "veut", "voulons", "voulez", "veulent"]
          },
          
          savoir: {
            infinitif: "savoir",
            participePresent: "sachant",
            indicatifPresent: ["sais", "sais", "sait", "savons", "savez", "savent"]
          },
          
          dire: {
            infinitif: "dire",
            participePresent: "disant",
            indicatifPresent: ["dis", "dis", "dit", "disons", "dites", "disent"]
          },
          
          partir: {
            infinitif: "partir",
            participePresent: "partant",
            indicatifPresent: ["pars", "pars", "part", "partons", "partez", "partent"]
          },
          
          venir: {
            infinitif: "venir",
            participePresent: "venant",
            indicatifPresent: ["viens", "viens", "vient", "venons", "venez", "viennent"]
          },
          
          devoir: {
            infinitif: "devoir",
            participePresent: "devant",
            indicatifPresent: ["dois", "dois", "doit", "devons", "devez", "doivent"]
          },
          
          appr√©cier: {
            infinitif: "appr√©cier",
            participePresent: "appr√©ciant",
            indicatifPresent: ["appr√©cie", "appr√©cies", "appr√©cie", "appr√©cions", "appr√©ciez", "appr√©cient"]
          }
        }
      },
      
      // TERMINAISONS VERBALES pour l'analyse morphologique
      verbEndings: {
        // Terminaisons 1er groupe (-er) - pr√©sent de l'indicatif
        firstGroup: {
          indicatifPresent: ["e", "es", "e", "ons", "ez", "ent"]
        },
        
        // Terminaisons 2√®me groupe (-ir) - pr√©sent de l'indicatif
        secondGroup: {
          indicatifPresent: ["is", "is", "it", "issons", "issez", "issent"]
        },
        
        // Terminaisons 3√®me groupe - pr√©sent de l'indicatif (diverses)
        thirdGroup: {
          indicatifPresent: ["s", "s", "t", "ons", "ez", "ent", 
                             "ds", "ds", "d", "dons", "dez", "dent",
                             "x", "x", "t", "ons", "ez", "ent"]
        },
        
        // Terminaisons participiales
        participePresent: ["ant"],
        participePassePremierGroupe: ["√©", "√©e", "√©s", "√©es"]
      },
      
      // TERMINAISONS ADJECTIVALES - pour identification morphologique des adjectifs
      adjectiveEndings: {
        // Terminaisons masculines
        masculine: [
          // Terminaisons simples
          "able", "ible", "al", "el", "esque", "eux", "iste", "if", "ant", "ent",
          // Terminaisons compos√©es pour nationalit√©s et origines
          "ais", "ien", "ain", "ard", "ois", "ique", "in", "ien", "an", "ique", "ard", "erbe",
          // Adjectifs de couleur
          "blanc", "bleu", "rouge", "vert", "jaune", "noir", "gris", "brun", "mauve", "rose"
        ],
        
        // Terminaisons f√©minines
        feminine: [
          "able", "ible", "ale", "elle", "esque", "euse", "iste", "ive", "ante", "ente",
          "aise", "ienne", "aine", "arde", "oise", "ique", "ine", "ienne", "ane", "ique", "arde", "erbe",
          "blanche", "bleue", "rouge", "verte", "jaune", "noire", "grise", "brune", "mauve", "rose"
        ],
        
        // Terminaisons plurielles
        plural: [
          "ables", "ibles", "als", "aux", "els", "esques", "eux", "istes", "ifs", "ives", 
          "ants", "ents", "antes", "entes",
          "ais", "iens", "ains", "ards", "ois", "iques", "ins", "iens", "ans", "iques", "ards", "erbes",
          "blancs", "bleus", "rouges", "verts", "jaunes", "noirs", "gris", "bruns", "mauves", "roses"
        ]
      }
    };
    
    // Fonction pour tokeniser et normaliser le texte
    function tokenizeText(text) {
      const tokens = [];
      
      // Pr√©traitement pour garantir des espaces autour des apostrophes
      let processedText = text.replace(/([a-zA-Z√Ä-√ø])'([a-zA-Z√Ä-√ø])/g, "$1' $2");
      
      // Diviser le texte par espaces et ponctuation
      const rawTokens = processedText.match(/[a-zA-Z√Ä-√ø'']+|[.,!?;:()]/g) || [];
      
      // Traiter chaque token
      for (let i = 0; i < rawTokens.length; i++) {
        const token = rawTokens[i];
        
        // Ignorer les tokens vides
        if (!token.trim()) continue;
        
        // Traiter les signes de ponctuation
        if (/^[.,!?;:()]$/.test(token)) {
          tokens.push({ 
            original: token, 
            normalized: token, 
            type: "punctuation" 
          });
          continue;
        }
        
        // Traiter les √©lisions (j', l', etc.)
        if (token.endsWith("'")) {
          // D√©terminer le type d'√©lision
          let normalizedToken = token.slice(0, -1).toLowerCase();
          
          // Mapper les √©lisions courantes √† leur forme compl√®te
          if (normalizedToken === "j") normalizedToken = "je";
          else if (normalizedToken === "c") normalizedToken = "ce";
          else if (normalizedToken === "s") normalizedToken = "se";
          else if (normalizedToken === "d") normalizedToken = "de";
          else if (normalizedToken === "l") normalizedToken = "le";
          else if (normalizedToken === "m") normalizedToken = "me";
          else if (normalizedToken === "n") normalizedToken = "ne";
          else if (normalizedToken === "t") normalizedToken = "te";
          else if (normalizedToken === "qu") normalizedToken = "que";
          
          tokens.push({
            original: token,
            normalized: normalizedToken,
            isElided: true
          });
          
          continue;
        }
        
        // Token standard
        tokens.push({
          original: token,
          normalized: token.toLowerCase()
        });
      }
      
      return tokens;
    }
    
    // Fonction principale d'analyse grammaticale
    function analyzeGrammar(tokens) {
      // R√©sultats de l'analyse
      const analyzedTokens = [];
      
      // Premier passage: √©tiquetage morphologique initial
      tokens.forEach((token, index) => {
        if (token.type === "punctuation") {
          analyzedTokens.push(token);
          return;
        }
        
        // Appliquer l'analyse morphologique pour d√©terminer le type grammatical
        const wordType = identifyWordType(token.normalized, tokens, index);
        
        analyzedTokens.push({
          ...token,
          ...wordType
        });
      });
      
      // Deuxi√®me passage: analyse syntaxique et contextuelle
      for (let i = 0; i < analyzedTokens.length; i++) {
        const token = analyzedTokens[i];
        if (token.type === "punctuation") continue;
        
        // R√©solution des ambigu√Øt√©s en fonction du contexte
        resolveAmbiguities(analyzedTokens, i);
        
        // D√©tection des structures grammaticales sp√©cifiques
        detectSpecificStructures(analyzedTokens, i);
      }
      
      return analyzedTokens;
    }
    
    // Identifier le type grammatical d'un mot
    function identifyWordType(word, tokens, position) {
      // 1. V√©rification des mots invariables (pr√©positions, conjonctions, adverbes)
      
      // V√©rifier si c'est une pr√©position
      if (frenchGrammar.prepositions.includes(word)) {
        return { type: "preposition" };
      }
      
      // V√©rifier si c'est une conjonction de coordination
      if (frenchGrammar.conjunctions.coordination.includes(word)) {
        return { type: "conjunction", subtype: "coordination" };
      }
      
      // V√©rifier si c'est une conjonction de subordination
      for (const subConj of frenchGrammar.conjunctions.subordination) {
        if (word === subConj || word.startsWith(subConj + " ")) {
          return { type: "conjunction", subtype: "subordination" };
        }
      }
      
      // V√©rifier si c'est un adverbe
      if (frenchGrammar.adverbs.includes(word)) {
        return { type: "adverb" };
      }
      
      // V√©rifier si c'est une n√©gation
      if (frenchGrammar.negations.includes(word)) {
        return { type: "negation" };
      }
      
      // 2. V√©rification des pronoms
      for (const [category, pronounList] of Object.entries(frenchGrammar.pronouns)) {
        if (pronounList.includes(word)) {
          return { type: "pronoun", subtype: category };
        }
      }
      
      // 3. V√©rification des d√©terminants
      // Articles d√©finis, ind√©finis et partitifs
      for (const [category, articleList] of Object.entries(frenchGrammar.determiners.articles)) {
        if (articleList.includes(word)) {
          return { type: "determiner", subtype: "article " + category };
        }
      }
      
      // Autres d√©terminants
      for (const [category, determinerList] of Object.entries(frenchGrammar.determiners)) {
        if (category !== "articles" && Array.isArray(determinerList) && determinerList.includes(word)) {
          return { type: "determiner", subtype: category };
        }
      }
      
      // 4. V√©rification des noms communs connus
      if (frenchGrammar.nouns.common.includes(word)) {
        return { type: "noun", subtype: "common" };
      }
      
      // 5. ANALYSE DES PARTICIPES PR√âSENTS ET FORMES VERBALES
      
      // V√©rifier participes pr√©sents - priorit√© √©lev√©e car souvent mal identifi√©s
      if (word.endsWith("ant") && word.length > 4) {
        // V√©rifier dans les formes connues des verbes
        for (const [verbName, verbForms] of Object.entries(frenchGrammar.verbs.auxiliaries)) {
          if (verbForms.participePresent && verbForms.participePresent === word) {
            return {
              type: "verb",
              subtype: "auxiliary",
              infinitif: verbForms.infinitif,
              temps: "participePresent"
            };
          }
        }
        
        for (const [verbName, verbForms] of Object.entries(frenchGrammar.verbs.common)) {
          if (verbForms.participePresent && verbForms.participePresent === word) {
            return {
              type: "verb",
              infinitif: verbForms.infinitif,
              temps: "participePresent"
            };
          }
        }
        
        // Si pas trouv√© dans les formes connues, essayer de d√©duire l'infinitif
        // Pour les verbes du 1er groupe
        const stem = word.substring(0, word.length - 3); // enlever "ant"
        if (stem.length >= 2) {
          const possibleInfinitif = stem + "er";
          return {
            type: "verb",
            infinitif: possibleInfinitif,
            temps: "participePresent"
          };
        }
      }
      
      // 6. ANALYSE CONTEXTUELLE PRIORITAIRE
      // Si le mot est pr√©c√©d√© par un pronom personnel sujet, c'est probablement un verbe
      if (position > 0) {
        const prevToken = tokens[position-1];
        const prevWord = prevToken ? prevToken.normalized : "";
        
        // Liste des pronoms personnels sujets
        const subjectPronouns = ["je", "j'", "tu", "il", "elle", "on", "nous", "vous", "ils", "elles"];
        
        if (subjectPronouns.includes(prevWord)) {
          // Recherche dans les verbes connus
          for (const [verbName, verbForms] of Object.entries(frenchGrammar.verbs.common)) {
            if (verbForms.indicatifPresent && verbForms.indicatifPresent.includes(word)) {
              return { 
                type: "verb", 
                infinitif: verbForms.infinitif,
                temps: "indicatifPresent" 
              };
            }
          }
          
          // Si ce n'est pas trouv√© dans les verbes connus mais suit un pronom personnel,
          // c'est tr√®s probablement un verbe √† l'indicatif pr√©sent
          if (word.length > 1) {
            // Recherche par terminaisons verbales
            // Pour le premier groupe (-er)
            const firstGroupEndings = frenchGrammar.verbEndings.firstGroup.indicatifPresent;
            for (let i = 0; i < firstGroupEndings.length; i++) {
              const ending = firstGroupEndings[i];
              // V√©rifie si le mot se termine par cette terminaison
              if (word.endsWith(ending) && word.length > ending.length) {
                const stem = word.substring(0, word.length - ending.length);
                // Reconstitue l'infinitif probable
                const infinitif = stem + "er";
                return { 
                  type: "verb", 
                  infinitif: infinitif,
                  temps: "indicatifPresent",
                  personne: i + 1
                };
              }
            }
            
            // Autres v√©rifications pour les verbes du 2e et 3e groupes...
            // Ces v√©rifications n√©cessiteraient des r√®gles plus complexes
          }
          
          // Par d√©faut, si apr√®s pronom sujet, consid√©rer comme verbe
          return { 
            type: "verb", 
            temps: "indicatifPresent", 
            note: "identifi√© par position apr√®s pronom sujet" 
          };
        }
      }
      
      // 7. V√©rification des verbes auxiliaires
      for (const [auxName, auxForms] of Object.entries(frenchGrammar.verbs.auxiliaries)) {
        // V√©rifier l'infinitif
        if (word === auxForms.infinitif) {
          return { 
            type: "verb", 
            subtype: "auxiliary", 
            infinitif: auxForms.infinitif,
            temps: "infinitif" 
          };
        }
        
        // V√©rifier les formes conjugu√©es
        for (const [tense, forms] of Object.entries(auxForms)) {
          if (Array.isArray(forms) && forms.includes(word)) {
            return { 
              type: "verb", 
              subtype: "auxiliary", 
              infinitif: auxForms.infinitif,
              temps: tense
            };
          }
        }
      }
      
      // 8. V√©rification des verbes communs
      for (const [verbName, verbForms] of Object.entries(frenchGrammar.verbs.common)) {
        // V√©rifier l'infinitif
        if (word === verbForms.infinitif) {
          return { 
            type: "verb", 
            infinitif: verbForms.infinitif,
            temps: "infinitif" 
          };
        }
        
        // V√©rifier les formes conjugu√©es
        for (const [tense, forms] of Object.entries(verbForms)) {
          if (Array.isArray(forms) && forms.includes(word)) {
            return { 
              type: "verb", 
              infinitif: verbForms.infinitif,
              temps: tense
            };
          }
        }
      }
      
      // 9. Analyse par terminaisons verbales
      if (word.endsWith("er") && word.length > 3) {
        // √âviter les noms en -er comme dossier, cahier
        const nominalExceptions = ["dossier", "cahier", "papier", "tablier", "pilier", "escalier"];
        if (!nominalExceptions.includes(word)) {
          return { 
            type: "verb", 
            infinitif: word,
            temps: "infinitif"
          };
        }
      }
      
      if (word.endsWith("ir") && word.length > 3) {
        return { 
          type: "verb", 
          infinitif: word,
          temps: "infinitif"
        };
      }
      
      if (word.endsWith("re") && word.length > 3) {
        return { 
          type: "verb", 
          infinitif: word,
          temps: "infinitif"
        };
      }
      
      // 10. Participes pass√©s
      if ((word.endsWith("√©") || word.endsWith("√©e") || word.endsWith("√©s") || word.endsWith("√©es")) && word.length > 3) {
        // Reconstruire l'infinitif probable
        const stem = word.slice(0, -1); // enlever l'accent
        const infinitif = stem + "er";
        
        return { 
          type: "verb", 
          infinitif: infinitif,
          temps: "participePass√©"
        };
      }
      
      // 11. ALGORITHME POUR IDENTIFIER LES ADJECTIFS QUALIFICATIFS PAR ANALYSE MORPHOLOGIQUE
      // Au lieu de simplement v√©rifier dans une liste, nous utilisons une identification par terminaisons et contexte
      
      // V√©rifier les terminaisons adjectivales
      // Cette m√©thode morphologique identifie les adjectifs par leurs suffixes caract√©ristiques
      if (identifyAdjectiveByEnding(word)) {
        return { type: "adjective", subtype: "qualificatif" };
      }
      
      // Analyse contextuelle pour les adjectifs - position par rapport aux noms
      if (position > 0 && position < tokens.length - 1) {
        // V√©rifier si c'est entre un d√©terminant et un nom (ex: "le grand chat")
        const prevToken = tokens[position - 1];
        const nextToken = tokens[position + 1];
        
        if (isDeterminer(prevToken.normalized) && !isVerb(word) && !isPreposition(word) && !isAdverb(word)) {
          // Si le mot suivant semble √™tre un nom, alors c'est probablement un adjectif
          if (isLikelyNoun(nextToken.normalized)) {
            return { type: "adjective", subtype: "qualificatif", position: "avant le nom" };
          }
        }
        
        // V√©rifier si c'est apr√®s un nom (ex: "un livre int√©ressant")
        if (isLikelyNoun(prevToken.normalized) && !isVerb(word) && !isPreposition(word)) {
          return { type: "adjective", subtype: "qualificatif", position: "apr√®s le nom" };
        }
        
        // V√©rifier si c'est apr√®s un verbe d'√©tat (ex: "il est grand")
        if (isStateVerb(prevToken.normalized) && !isVerb(word) && !isPreposition(word) && !isAdverb(word)) {
          return { type: "adjective", subtype: "qualificatif", position: "attribut du sujet" };
        }
      }
      
      // 12. Analyse par terminaisons nominales
      if (word.endsWith("tion") || word.endsWith("sion") || 
          word.endsWith("ment") || word.endsWith("age") || 
          word.endsWith("t√©") || word.endsWith("it√©") || 
          word.endsWith("eur") || word.endsWith("esse") || 
          word.endsWith("ance") || word.endsWith("ence")) {
        return { type: "noun" };
      }
      
      // 13. Analyse contextuelle
      // Si pr√©c√©d√© par un d√©terminant, probablement un nom
      if (position > 0) {
        const prevToken = tokens[position-1];
        if (prevToken && isDeterminer(prevToken.normalized)) {
          return { type: "noun" };
        }
      }
      
      // Si pr√©c√©d√© par une pr√©position, souvent un nom
      if (position > 0 && tokens[position-1] && 
          frenchGrammar.prepositions.includes(tokens[position-1].normalized)) {
        return { type: "noun" };
      }
      
      // 14. Cas par d√©faut: on suppose que c'est un nom (hypoth√®se la plus probable)
      return { type: "noun", subtype: "default" };
    }
    
    // FONCTION AVANC√âE POUR IDENTIFIER LES ADJECTIFS QUALIFICATIFS
    function identifyAdjectiveByEnding(word) {
      // Convertir en minuscules pour la comparaison
      const lowercaseWord = word.toLowerCase();
      
      // 1. V√©rifier les terminaisons caract√©ristiques des adjectifs
      const { masculine, feminine, plural } = frenchGrammar.adjectiveEndings;
      
      // V√©rifier par ordre de sp√©cificit√© (du plus sp√©cifique au plus g√©n√©ral)
      
      // Terminaisons adjectivales masculines complexes
      for (const ending of masculine) {
        if (ending.length > 2 && lowercaseWord.endsWith(ending) && lowercaseWord.length > ending.length) {
          return true;
        }
      }
      
      // Terminaisons adjectivales f√©minines complexes
      for (const ending of feminine) {
        if (ending.length > 2 && lowercaseWord.endsWith(ending) && lowercaseWord.length > ending.length) {
          return true;
        }
      }
      
      // Terminaisons adjectivales au pluriel
      for (const ending of plural) {
        if (ending.length > 2 && lowercaseWord.endsWith(ending) && lowercaseWord.length > ending.length) {
          return true;
        }
      }
      
      // 2. V√©rification morphologique: si le mot peut former un adverbe en -ment
      // Les adjectifs f√©minins peuvent souvent √™tre transform√©s en adverbes en ajoutant -ment
      for (const femEnding of ["e", "le", "ne", "te", "se", "ce", "de"]) {
        if (lowercaseWord.endsWith(femEnding)) {
          const possibleAdverb = lowercaseWord + "ment";
          // La v√©rification compl√®te n√©cessiterait une liste d'adverbes pour valider
          // Mais cette heuristique peut aider √† identifier certains adjectifs
          if (possibleAdverb.length > 6) {
            return true;
          }
        }
      }
      
      // 3. V√©rification des suffixes typiquement adjectivaux
      const adjectiveSuffixes = [
        "able", "ible", "uble", "al", "el", "il", "esque", "ien", "ain", "ais", 
        "ois", "if", "atif", "itif", "eux", "oux", "iste", "ique", "√®me"
      ];
      
      for (const suffix of adjectiveSuffixes) {
        if (lowercaseWord.endsWith(suffix) && lowercaseWord.length > suffix.length + 1) {
          return true;
        }
      }
      
      return false;
    }
    
    // FONCTION POUR IDENTIFIER LES FORMES VERBALES PAR TERMINAISON
    function identifyVerbByEnding(word) {
      // Convertir en minuscules pour la comparaison
      const lowercaseWord = word.toLowerCase();
      
      // Terminaisons verbales fr√©quentes pour le pr√©sent de l'indicatif
      const presentEndings = {
        firstPerson: ["e", "s", "x", "is", "ns"],  // je ...
        secondPerson: ["es", "s", "x", "is"],      // tu ...
        thirdPerson: ["e", "t", "d", "it"],        // il/elle ...
        firstPersonPlural: ["ons", "mes"],         // nous ...
        secondPersonPlural: ["ez", "tes"],         // vous ...
        thirdPersonPlural: ["ent", "ont"]          // ils/elles ...
      };
      
      // V√©rifier pour chaque personne
      for (const [person, endings] of Object.entries(presentEndings)) {
        for (const ending of endings) {
          if (lowercaseWord.endsWith(ending) && lowercaseWord.length > ending.length + 1) {
            // V√©rifier que ce n'est pas un mot avec une terminaison similaire mais non verbale
            // (par exemple "table" se termine par "e" mais n'est pas un verbe)
            const stem = lowercaseWord.slice(0, -ending.length);
            
            // Les tiges verbales ont g√©n√©ralement au moins 2 caract√®res
            if (stem.length >= 2) {
              return { isVerb: true, person: person };
            }
          }
        }
      }
      
      return { isVerb: false };
    }
    
    // Fonctions d'aide pour l'analyse contextuelle
    function isDeterminer(word) {
      // V√©rifier dans tous les types de d√©terminants
      for (const [category, list] of Object.entries(frenchGrammar.determiners.articles)) {
        if (list.includes(word)) return true;
      }
      
      for (const [category, list] of Object.entries(frenchGrammar.determiners)) {
        if (category !== "articles" && Array.isArray(list) && list.includes(word)) {
          return true;
        }
      }
      
      return false;
    }
    
    function isVerb(word) {
      // V√©rifier les auxiliaires
      for (const [aux, forms] of Object.entries(frenchGrammar.verbs.auxiliaries)) {
        if (word === forms.infinitif) return true;
        
        for (const [tense, tenseforms] of Object.entries(forms)) {
          if (Array.isArray(tenseforms) && tenseforms.includes(word)) {
            return true;
          }
        }
      }
      
      // V√©rifier les verbes communs
      for (const [verb, forms] of Object.entries(frenchGrammar.verbs.common)) {
        if (word === forms.infinitif) return true;
        
        for (const [tense, tenseforms] of Object.entries(forms)) {
          if (Array.isArray(tenseforms) && tenseforms.includes(word)) {
            return true;
          }
        }
      }
      
      // V√©rifier par terminaisons verbales
      if (word.endsWith("er") || word.endsWith("ir") || word.endsWith("re")) {
        return true;
      }
      
      // V√©rifier par l'analyse morphologique des terminaisons
      const verbAnalysis = identifyVerbByEnding(word);
      if (verbAnalysis.isVerb) {
        return true;
      }
      
      return false;
    }
    
    function isPreposition(word) {
      return frenchGrammar.prepositions.includes(word);
    }
    
    function isAdverb(word) {
      return frenchGrammar.adverbs.includes(word);
    }
    
    function isPersonalPronoun(word) {
      return frenchGrammar.pronouns.personal.includes(word);
    }
    
    function isLikelyNoun(word) {
      // V√©rifier si c'est un nom connu
      if (frenchGrammar.nouns.common.includes(word)) {
        return true;
      }
      
      // Noms ont souvent des terminaisons sp√©cifiques
      const nounSuffixes = ["tion", "sion", "ment", "age", "ance", "ence", "it√©", "isme", "esse", "ie", "ure"];
      
      for (const suffix of nounSuffixes) {
        if (word.endsWith(suffix)) return true;
      }
      
      return false;
    }
    
    function isStateVerb(word) {
      // Verbes d'√©tat (√™tre, sembler, para√Ætre, devenir, demeurer, rester, etc.)
      const stateVerbs = ["suis", "es", "est", "sommes", "√™tes", "sont", "√©tais", "√©tait", "√©taient", 
                         "semble", "sembles", "semblent", "para√Æt", "paraissent", 
                         "devient", "deviennent", "demeure", "demeurent", "reste", "restent",
                         "parais", "demeures", "restes", "deviens"];
      
      return stateVerbs.includes(word);
    }
    
    // R√©soudre les ambigu√Øt√©s grammaticales en fonction du contexte
    function resolveAmbiguities(tokens, position) {
      const token = tokens[position];
      if (!token || token.type === "punctuation") return;
      
      // 1. Traitement prioritaire pour les mots apr√®s pronoms personnels sujets
      if (position > 0) {
        const prevToken = tokens[position - 1];
        if (prevToken && prevToken.type === "pronoun" && prevToken.subtype === "personal") {
          // V√©rifier s'il s'agit d'un pronom sujet
          const subjectPronouns = ["je", "j'", "tu", "il", "elle", "on", "nous", "vous", "ils", "elles"];
          if (subjectPronouns.includes(prevToken.normalized)) {
            // Si le mot n'est pas d√©j√† identifi√© comme verbe et n'est pas clairement autre chose
            if (token.type !== "verb" && token.type !== "adverb" && token.type !== "preposition" && 
                token.type !== "conjunction" && token.type !== "negation") {
              token.type = "verb";
              token.role = "apr√®s pronom personnel sujet";
              
              // Essayer de d√©duire l'infinitif
              if (token.normalized.endsWith("e")) {
                const stem = token.normalized.slice(0, -1);
                token.infinitif = stem + "er";
                token.temps = "indicatifPresent";
              }
            }
          }
        }
      }
      
      // 2. Analyse des s√©quences "auxiliaire + participe pass√©"
      if (position > 0 && position < tokens.length - 1) {
        const prevToken = tokens[position - 1];
        
        // Si ce mot est un participe pass√© et le pr√©c√©dent est une forme de avoir ou √™tre
        if (token.temps === "participePass√©" && prevToken.type === "verb" && 
            (prevToken.infinitif === "avoir" || prevToken.infinitif === "√™tre")) {
          // Confirmer que c'est bien un verbe
          token.type = "verb";
          token.role = "participe dans temps compos√©";
          
          // Identifier l'auxiliaire
          prevToken.role = "auxiliaire dans temps compos√©";
        }
      }
    }
    
    // D√©tecter des structures grammaticales sp√©cifiques
    function detectSpecificStructures(tokens, position) {
      const token = tokens[position];
      if (!token || token.type === "punctuation") return;
      
      // Structure "√™tre + adjectif"
      if (position > 0) {
        const prevToken = tokens[position - 1];
        
        if (prevToken.type === "verb" && prevToken.infinitif === "√™tre") {
          // Si ce n'est pas clairement un verbe ou un nom, c'est probablement un adjectif
          if (token.type !== "verb" && token.type !== "adverb" && token.type !== "preposition") {
            token.type = "adjective";
            token.role = "attribut du sujet";
          }
        }
      }
    }
    
    // Regrouper les r√©sultats par cat√©gorie grammaticale
    function categorizeResults(analyzedTokens) {
      const categories = {
        pronoun: [],
        verb: [],
        noun: [],
        adjective: [],
        determiner: [],
        adverb: [],
        preposition: [],
        conjunction: [],
        negation: [],
        interjection: []
      };
      
      analyzedTokens.forEach(token => {
        if (token.type === "punctuation") return;
        
        if (token.type in categories) {
          // √âviter les doublons dans chaque cat√©gorie
          const exists = categories[token.type].some(item => 
            item.normalized === token.normalized
          );
          
          if (!exists) {
            categories[token.type].push(token);
          }
        }
      });
      
      return categories;
    }
    
    // G√©n√©rer le HTML pour afficher une cat√©gorie grammaticale
    function generateCategoryHTML(category, items) {
      if (!items || items.length === 0) return '';
      
      let html = `
        <div class="category-header">
          <div class="category-badge ${category}-badge">${categoryNames[category]}</div>
          <div class="category-description">${categoryDescriptions[category]}</div>
        </div>
        <div class="category-content">
      `;
      
      items.forEach(item => {
        let displayText = item.original;
        
        // Ajouter des informations pertinentes selon la cat√©gorie
        if (category === "verb" && item.infinitif) {
          displayText = `${item.original}`;
          if (item.infinitif !== item.original.toLowerCase()) {
            displayText += ` [${item.infinitif}`;
            if (item.temps) {
              displayText += ` (${item.temps})`;
            }
            displayText += `]`;
          }
        } 
        else if (item.role) {
          displayText = `${item.original} [${item.role}]`;
        }
        
        html += `<span class="word-tag ${category} tooltip">${displayText}<span class="tooltip-text">${categoryNames[category]}${item.subtype ? ` ${item.subtype}` : ''}</span></span>`;
      });
      
      html += `
        </div>
      `;
      
      return html;
    }
    
    // Formatter le texte analys√© en HTML avec des √©tiquettes de couleur
    function formatAnalyzedText(analyzedTokens) {
      let html = '';
      
      analyzedTokens.forEach(token => {
        if (token.type === "punctuation") {
          html += token.original;
        } else {
          const tooltipContent = `${categoryNames[token.type]}${token.subtype ? ` ${token.subtype}` : ''}`;
          
          html += `<span class="word-tag ${token.type} tooltip">${token.original}<span class="tooltip-text">${tooltipContent}</span></span> `;
        }
      });
      
      return html;
    }
    
    // Obtenir l'heure actuelle format√©e
    function getCurrentTime() {
      const now = new Date();
      let hours = now.getHours();
      let minutes = now.getMinutes();
      
      // Ajouter un 0 devant les chiffres < 10
      hours = hours < 10 ? '0' + hours : hours;
      minutes = minutes < 10 ? '0' + minutes : minutes;
      
      return `${hours}:${minutes}`;
    }
    
    // Ajouter un message utilisateur au chat
    function addUserMessage(text) {
      const chatContainer = document.getElementById('chatContainer');
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message user';
      messageDiv.innerHTML = `
        <div class="message-content">${text}</div>
        <div class="message-time">${getCurrentTime()}</div>
      `;
      
      chatContainer.appendChild(messageDiv);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }
    
    // Ajouter un indicateur de saisie
    function addTypingIndicator() {
      const chatContainer = document.getElementById('chatContainer');
      const typingDiv = document.createElement('div');
      typingDiv.className = 'typing-indicator';
      typingDiv.id = 'typingIndicator';
      typingDiv.innerHTML = `
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
      `;
      
      chatContainer.appendChild(typingDiv);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }
    
    // Supprimer l'indicateur de saisie
    function removeTypingIndicator() {
      const typingIndicator = document.getElementById('typingIndicator');
      if (typingIndicator) {
        typingIndicator.remove();
      }
    }
    
    // Ajouter un message bot au chat
    function addBotMessage(content) {
      removeTypingIndicator();
      
      const chatContainer = document.getElementById('chatContainer');
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message bot';
      messageDiv.innerHTML = `
        <div class="message-content">${content}</div>
        <div class="message-time">${getCurrentTime()}</div>
      `;
      
      chatContainer.appendChild(messageDiv);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }
    
    // Fonction principale pour analyser la phrase
    function analyzeSentence(text) {
      try {
        // Tokeniser le texte
        const tokens = tokenizeText(text);
        
        // Analyser la grammaire
        const analyzedTokens = analyzeGrammar(tokens);
        
        // Regrouper les r√©sultats par cat√©gorie
        const categorizedResults = categorizeResults(analyzedTokens);
        
        // Formater le texte analys√©
        const analyzedTextHtml = formatAnalyzedText(analyzedTokens);
        
        // Pr√©parer la r√©ponse
        let response = `Voici l'analyse de votre phrase:<br><br>${analyzedTextHtml}<br><br>`;
        
        // Ajouter les cat√©gories grammaticales
        response += `<div class="category-list">`;
        
        // Ordre des cat√©gories
        const categoryOrder = ['pronoun', 'verb', 'noun', 'adjective', 'determiner', 'adverb', 'preposition', 'conjunction', 'negation', 'interjection'];
        
        categoryOrder.forEach(category => {
          const items = categorizedResults[category];
          if (items && items.length > 0) {
            response += generateCategoryHTML(category, items);
          }
        });
        
        response += `</div>`;
        
        return response;
      } catch (error) {
        console.error("Erreur lors de l'analyse:", error);
        return `Une erreur s'est produite lors de l'analyse: ${error.message}`;
      }
    }
    
    // Gestionnaire d'√©v√©nements
    document.addEventListener('DOMContentLoaded', function() {
      const userInput = document.getElementById('userInput');
      const sendButton = document.getElementById('sendButton');
      
      // Fonction pour envoyer le message
      function sendMessage() {
        const text = userInput.value.trim();
        if (!text) return;
        
        // Afficher le message de l'utilisateur
        addUserMessage(text);
        
        // Effacer l'entr√©e
        userInput.value = '';
        
        // Afficher l'indicateur de saisie
        addTypingIndicator();
        
        // Analyser la phrase apr√®s un court d√©lai pour montrer l'animation
        setTimeout(function() {
          const response = analyzeSentence(text);
          addBotMessage(response);
        }, 1000);
      }
      
      // √âcouter le clic sur le bouton d'envoi
      sendButton.addEventListener('click', sendMessage);
      
      // √âcouter la touche Entr√©e dans l'input
      userInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          sendMessage();
        }
      });
      
      // Focus sur l'input au chargement
      userInput.focus();
    });
  </script>
</body>
</html>
