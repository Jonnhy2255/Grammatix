<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Analyseur Grammatical</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Roboto:wght@300;400;500&display=swap');
    
    :root {
      --primary-color: #5D5CDE;
      --primary-glow: rgba(93, 92, 222, 0.6);
      --secondary-color: #00e5ff;
      --secondary-glow: rgba(0, 229, 255, 0.5);
      --accent-color: #ff00e5;
      --accent-glow: rgba(255, 0, 229, 0.5);
      --success-color: #00ff9d;
      --success-glow: rgba(0, 255, 157, 0.5);
      --warning-color: #ffae00;
      --warning-glow: rgba(255, 174, 0, 0.5);
      --danger-color: #ff3471;
      --danger-glow: rgba(255, 52, 113, 0.5);
      --dark-bg: #121223;
      --card-bg: #1a1a2e;
      --input-bg: #0c0c1d;
      --border-color: #2a2a4a;
      --text-color: #e0e0ff;
      --text-secondary: #9090c0;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Roboto', sans-serif;
      background-color: var(--dark-bg);
      color: var(--text-color);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow-x: hidden;
    }
    
    /* Background animated gradient */
    body::before {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at 20% 30%, rgba(93, 92, 222, 0.1) 0%, transparent 30%),
                  radial-gradient(circle at 80% 20%, rgba(0, 229, 255, 0.07) 0%, transparent 30%),
                  radial-gradient(circle at 30% 70%, rgba(255, 0, 229, 0.07) 0%, transparent 25%);
      z-index: -1;
      pointer-events: none;
    }
    
    .container {
      max-width: 900px;
      width: 100%;
      margin: 0 auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      flex-grow: 1;
    }
    
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 0;
      margin-bottom: 1.5rem;
      border-bottom: 1px solid var(--border-color);
    }
    
    h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.75rem;
      color: var(--primary-color);
      text-shadow: 0 0 10px var(--primary-glow);
      letter-spacing: 1px;
    }
    
    .system-status {
      display: flex;
      align-items: center;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }
    
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: var(--success-color);
      box-shadow: 0 0 10px var(--success-glow);
      margin-right: 0.5rem;
      position: relative;
    }
    
    .status-dot::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background-color: var(--success-color);
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 0.8;
      }
      50% {
        transform: scale(2.5);
        opacity: 0;
      }
      100% {
        transform: scale(1);
        opacity: 0;
      }
    }
    
    /* Chat container */
    .chat-container {
      flex-grow: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      margin-bottom: 1rem;
      padding-right: 0.5rem;
      max-height: calc(100vh - 170px);
    }
    
    /* Scrollbar */
    .chat-container::-webkit-scrollbar {
      width: 6px;
    }
    
    .chat-container::-webkit-scrollbar-track {
      background: var(--input-bg);
      border-radius: 10px;
    }
    
    .chat-container::-webkit-scrollbar-thumb {
      background: var(--primary-color);
      border-radius: 10px;
    }
    
    /* Chat messages */
    .message {
      max-width: 85%;
      margin-bottom: 1rem;
      padding: 0.75rem 1rem;
      border-radius: 1.2rem;
      position: relative;
      animation: fadeIn 0.3s ease-out;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .message.user {
      align-self: flex-end;
      background-color: var(--primary-color);
      box-shadow: 0 0 15px var(--primary-glow);
      border-bottom-right-radius: 0.3rem;
    }
    
    .message.bot {
      align-self: flex-start;
      background-color: var(--card-bg);
      border: 1px solid var(--border-color);
      border-bottom-left-radius: 0.3rem;
    }
    
    .message-content {
      font-size: 0.95rem;
      line-height: 1.4;
    }
    
    .message-time {
      font-size: 0.7rem;
      color: rgba(255, 255, 255, 0.6);
      margin-top: 0.25rem;
      text-align: right;
    }
    
    /* Word tags in bot messages */
    .word-tag {
      display: inline-block;
      padding: 0.1rem 0.4rem;
      border-radius: 0.5rem;
      margin: 0.15rem 0.1rem;
      font-size: 0.9rem;
      font-weight: 500;
      transition: transform 0.2s, box-shadow 0.2s;
      cursor: help;
    }
    
    .word-tag:hover {
      transform: translateY(-2px);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
    }
    
    /* Codes couleur pour chaque catégorie grammaticale */
    .pronoun {
      background-color: #ff517a;
      color: #fff;
    }
    
    .verb {
      background-color: #00a3ff;
      color: #fff;
    }
    
    .determiner {
      background-color: #9c6bff;
      color: #fff;
    }
    
    .noun {
      background-color: #00cf86;
      color: #fff;
    }
    
    .adjective {
      background-color: #ffb347;
      color: #fff;
    }
    
    .adverb {
      background-color: #7c83ff;
      color: #fff;
    }
    
    .preposition {
      background-color: #ff65b2;
      color: #fff;
    }
    
    .conjunction {
      background-color: #c17aff;
      color: #fff;
    }
    
    .negation {
      background-color: #ff5252;
      color: #fff;
    }
    
    .interjection {
      background-color: #ffcc29;
      color: #333;
    }
    
    .subject {
      border: 2px solid #fff;
      padding: 0.15rem 0.45rem;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }
    
    .object {
      border-bottom: 2px dashed #fff;
    }
    
    /* Tooltip */
    .tooltip {
      position: relative;
    }
    
    .tooltip .tooltip-text {
      visibility: hidden;
      position: absolute;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(10, 10, 25, 0.95);
      color: var(--text-color);
      text-align: center;
      border-radius: 6px;
      padding: 0.5rem;
      width: max-content;
      max-width: 200px;
      font-size: 0.75rem;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.3s;
      border: 1px solid var(--border-color);
      pointer-events: none;
    }
    
    .tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }
    
    /* Category list */
    .category-list {
      background-color: var(--card-bg);
      border-radius: 0.6rem;
      padding: 1rem;
      margin-top: 0.5rem;
      border: 1px solid var(--border-color);
    }
    
    .category-header {
      display: flex;
      align-items: center;
      margin-bottom: 0.75rem;
    }
    
    .category-badge {
      padding: 0.3rem 0.6rem;
      border-radius: 0.5rem;
      font-size: 0.75rem;
      font-weight: bold;
      margin-right: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: white;
    }
    
    .pronoun-badge { background-color: #ff517a; }
    .verb-badge { background-color: #00a3ff; }
    .determiner-badge { background-color: #9c6bff; }
    .noun-badge { background-color: #00cf86; }
    .adjective-badge { background-color: #ffb347; }
    .adverb-badge { background-color: #7c83ff; }
    .preposition-badge { background-color: #ff65b2; }
    .conjunction-badge { background-color: #c17aff; }
    .negation-badge { background-color: #ff5252; }
    .interjection-badge { background-color: #ffcc29; color: #333; }
    
    .category-description {
      font-size: 0.8rem;
      color: var(--text-secondary);
    }
    
    .category-content {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }
    
    /* Sentence structure */
    .sentence-structure {
      background-color: var(--card-bg);
      border-radius: 0.6rem;
      padding: 1rem;
      margin-top: 1rem;
      border: 1px solid var(--border-color);
    }
    
    .structure-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 1rem;
      color: var(--primary-color);
      margin-bottom: 0.75rem;
    }
    
    .structure-item {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
    }
    
    .structure-label {
      width: 100px;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }
    
    .structure-value {
      flex-grow: 1;
      font-size: 0.9rem;
    }
    
    /* Input area */
    .input-container {
      position: relative;
      margin-top: auto;
    }
    
    .input-glow {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      border-radius: 16px;
      z-index: -1;
    }
    
    .input-container:focus-within .input-glow {
      box-shadow: 0 0 20px var(--primary-glow);
    }
    
    .chat-input {
      width: 100%;
      padding: 1rem 3.5rem 1rem 1.2rem;
      border-radius: 16px;
      border: 1px solid var(--border-color);
      background-color: var(--input-bg);
      color: var(--text-color);
      font-size: 1rem;
      outline: none;
      transition: all 0.3s;
      box-shadow: 0 0 20px rgba(93, 92, 222, 0.1);
    }
    
    .chat-input:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px var(--primary-glow);
    }
    
    .send-button {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: var(--primary-color);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      transition: all 0.2s;
    }
    
    .send-button:hover {
      background-color: var(--primary-color);
      color: white;
    }
    
    .send-button svg {
      width: 18px;
      height: 18px;
    }
    
    /* Loading animation */
    .typing-indicator {
      display: flex;
      padding: 0.5rem 1rem;
      background-color: var(--card-bg);
      border-radius: 1.2rem;
      border-bottom-left-radius: 0.3rem;
      align-self: flex-start;
      margin-bottom: 1rem;
      width: auto;
    }
    
    .typing-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: var(--text-secondary);
      margin: 0 2px;
      animation: typingBounce 1.4s infinite;
      opacity: 0.6;
    }
    
    .typing-dot:nth-child(1) { animation-delay: 0s; }
    .typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .typing-dot:nth-child(3) { animation-delay: 0.4s; }
    
    @keyframes typingBounce {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-5px); }
    }
    
    /* Futuristic scanner lines effect */
    .scanner-line {
      position: absolute;
      width: 100%;
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--secondary-color), transparent);
      animation: scan 4s infinite;
      opacity: 0.5;
      pointer-events: none;
    }
    
    @keyframes scan {
      0% {
        top: 0;
        opacity: 0;
      }
      5% {
        opacity: 0.8;
      }
      50% {
        top: 100%;
      }
      95% {
        opacity: 0.8;
      }
      100% {
        top: 0;
        opacity: 0;
      }
    }
    
    /* Responsive design */
    @media (max-width: 768px) {
      .container {
        padding: 0.75rem;
      }
      
      h1 {
        font-size: 1.4rem;
      }
      
      .message {
        max-width: 90%;
        padding: 0.6rem 0.75rem;
      }
      
      .chat-input {
        padding: 0.75rem 3rem 0.75rem 1rem;
      }
    }
    
    @media (max-width: 480px) {
      h1 {
        font-size: 1.1rem;
      }
      
      .system-status {
        font-size: 0.7rem;
      }
      
      .message {
        max-width: 95%;
      }
      
      .word-tag {
        font-size: 0.8rem;
        padding: 0.1rem 0.3rem;
      }
    }
  </style>
</head>
<body>
  <div class="scanner-line"></div>
  
  <div class="container">
    <header>
      <h1>DYNAMIC ANALYZER</h1>
      <div class="system-status">
        <div class="status-dot"></div>
        <span>Système opérationnel</span>
      </div>
    </header>
    
    <div class="chat-container" id="chatContainer">
      <div class="message bot">
        <div class="message-content">
          Bonjour, je suis votre <span class="word-tag adjective tooltip">intelligent<span class="tooltip-text">Adjectif qualificatif</span></span> analyseur grammatical. Écrivez une phrase en français, et je l'analyserai pour vous.
        </div>
        <div class="message-time">Aujourd'hui</div>
      </div>
    </div>
    
    <div class="input-container">
      <div class="input-glow"></div>
      <input type="text" class="chat-input" id="userInput" placeholder="Tapez votre phrase ici..." autocomplete="off">
      <button class="send-button" id="sendButton">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
        </svg>
      </button>
    </div>
  </div>

  <script>
    // Descriptions des catégories grammaticales
    const categoryDescriptions = {
      pronoun: "Les pronoms remplacent généralement un nom ou un groupe nominal.",
      verb: "Les verbes expriment des actions, des états ou des processus.",
      noun: "Les noms désignent des personnes, des lieux, des objets ou des concepts.",
      adjective: "Les adjectifs qualifient ou déterminent les noms.",
      determiner: "Les déterminants précisent l'identité ou la quantité du nom qu'ils accompagnent.",
      adverb: "Les adverbes modifient un verbe, un adjectif ou un autre adverbe.",
      preposition: "Les prépositions relient des mots ou groupes de mots entre eux.",
      conjunction: "Les conjonctions relient des mots, des propositions ou des phrases.",
      negation: "Les négations sont utilisées pour nier une affirmation.",
      interjection: "Les interjections expriment une émotion ou une réaction."
    };
    
    // Noms des catégories en français
    const categoryNames = {
      pronoun: "Pronom",
      verb: "Verbe",
      noun: "Nom",
      adjective: "Adjectif",
      determiner: "Déterminant",
      adverb: "Adverbe",
      preposition: "Préposition",
      conjunction: "Conjonction",
      negation: "Négation",
      interjection: "Interjection"
    };
    
    // Base de données linguistique française (lexique et règles)
    const frenchLexicon = {
      // Articles définis
      definiteArticles: {
        singular: ["le", "la", "l'"],
        plural: ["les"]
      },
      
      // Articles indéfinis
      indefiniteArticles: {
        singular: ["un", "une"],
        plural: ["des"]
      },
      
      // Articles partitifs
      partitiveArticles: ["du", "de la", "de l'", "des"],
      
      // Déterminants possessifs
      possessiveDeterminers: [
        "mon", "ma", "mes", 
        "ton", "ta", "tes", 
        "son", "sa", "ses", 
        "notre", "nos", 
        "votre", "vos", 
        "leur", "leurs"
      ],
      
      // Déterminants démonstratifs
      demonstrativeDeterminers: ["ce", "cet", "cette", "ces"],
      
      // Déterminants indéfinis
      indefiniteDeterminers: [
        "chaque", "quelque", "quelques", "tout", "toute", "tous", "toutes",
        "certain", "certaine", "certains", "certaines", "plusieurs", 
        "aucun", "aucune", "nul", "nulle", "autre", "autres",
        "même", "mêmes", "tel", "telle", "tels", "telles"
      ],
      
      // Pronoms personnels
      personalPronouns: {
        subject: ["je", "j'", "tu", "il", "elle", "on", "nous", "vous", "ils", "elles"],
        object: ["me", "m'", "te", "t'", "le", "l'", "la", "lui", "se", "s'", "nous", "vous", "les", "leur"],
        tonic: ["moi", "toi", "lui", "elle", "soi", "nous", "vous", "eux", "elles"],
        reflexive: ["me", "m'", "te", "t'", "se", "s'", "nous", "vous"],
        adverbial: ["y", "en"]
      },
      
      // Pronoms démonstratifs
      demonstrativePronouns: ["ce", "c'", "ça", "ceci", "cela", "celui", "celle", "ceux", "celles", "celui-ci", "celle-ci", "ceux-ci", "celles-ci"],
      
      // Pronoms relatifs
      relativePronouns: ["qui", "que", "qu'", "quoi", "dont", "où", "lequel", "laquelle", "lesquels", "lesquelles"],
      
      // Pronoms interrogatifs
      interrogativePronouns: ["qui", "que", "quoi", "lequel", "laquelle", "lesquels", "lesquelles"],
      
      // Pronoms indéfinis
      indefinitePronouns: ["on", "tout", "tous", "toute", "toutes", "aucun", "aucune", "nul", "nulle", "personne", "rien", "chacun", "chacune", "quelqu'un", "quelques-uns", "quelques-unes", "plusieurs", "certains", "certaines", "autre", "autres"],
      
      // Prépositions
      prepositions: [
        "à", "au", "aux", "après", "avant", "avec", "chez", "contre", "dans", 
        "de", "des", "du", "depuis", "derrière", "dès", "devant", "durant", 
        "en", "entre", "envers", "hormis", "hors", "jusque", "malgré", "outre", 
        "par", "parmi", "pendant", "pour", "près", "sans", "sauf", "selon", 
        "sous", "suivant", "sur", "vers", "via"
      ],
      
      // Conjonctions de coordination
      coordinatingConjunctions: ["et", "mais", "ou", "donc", "or", "ni", "car"],
      
      // Conjonctions de subordination
      subordinatingConjunctions: [
        "que", "qu'", "quand", "comme", "si", "lorsque", "puisque", "quoique", 
        "parce", "bien que", "afin que", "pour que", "tandis que", "alors que"
      ],
      
      // Adverbes courants
      commonAdverbs: [
        "ainsi", "alors", "assez", "aujourd'hui", "aussi", "autant", "autrefois", 
        "beaucoup", "bien", "bientôt", "certes", "combien", "comment", "davantage", 
        "debout", "dedans", "dehors", "déjà", "demain", "encore", "enfin", "ensemble", 
        "ensuite", "environ", "fort", "hier", "ici", "jamais", "là", "loin", 
        "longtemps", "lors", "maintenant", "mal", "mieux", "moins", "parfois", 
        "partout", "peu", "plus", "plusieurs", "plutôt", "presque", "puis", 
        "quasiment", "quelquefois", "seulement", "si", "souvent", "tant", 
        "tantôt", "tard", "tellement", "tôt", "toujours", "toutefois", "très", 
        "trop", "vite", "volontiers", "vraiment"
      ],
      
      // Mots de négation
      negationWords: ["ne", "n'", "pas", "plus", "jamais", "guère", "point", "nullement", "aucunement"],
      
      // Interjections
      interjections: ["ah", "oh", "eh", "hé", "aïe", "ouf", "hein", "bah", "pff", "zut", "youpi", "bravo", "hourra"],
      
      // Verbes auxiliaires
      auxiliaryVerbs: {
        avoir: {
          infinitive: "avoir",
          presentParticiple: "ayant",
          pastParticiple: ["eu", "eue", "eus", "eues"],
          present: {
            singular: ["ai", "as", "a"],
            plural: ["avons", "avez", "ont"]
          },
          imperfect: {
            singular: ["avais", "avais", "avait"],
            plural: ["avions", "aviez", "avaient"]
          },
          future: {
            singular: ["aurai", "auras", "aura"],
            plural: ["aurons", "aurez", "auront"]
          }
        },
        être: {
          infinitive: "être",
          presentParticiple: "étant",
          pastParticiple: ["été"],
          present: {
            singular: ["suis", "es", "est"],
            plural: ["sommes", "êtes", "sont"]
          },
          imperfect: {
            singular: ["étais", "étais", "était"],
            plural: ["étions", "étiez", "étaient"]
          },
          future: {
            singular: ["serai", "seras", "sera"],
            plural: ["serons", "serez", "seront"]
          }
        }
      },
      
      // Dictionnaire de verbes (exemples)
      verbs: {
        // Premier groupe (-er)
        "aimer": {
          infinitive: "aimer",
          group: 1,
          present: {
            singular: ["aime", "aimes", "aime"],
            plural: ["aimons", "aimez", "aiment"]
          }
        },
        "parler": {
          infinitive: "parler",
          group: 1,
          present: {
            singular: ["parle", "parles", "parle"],
            plural: ["parlons", "parlez", "parlent"]
          }
        },
        "donner": {
          infinitive: "donner",
          group: 1,
          present: {
            singular: ["donne", "donnes", "donne"],
            plural: ["donnons", "donnez", "donnent"]
          }
        },
        "trouver": {
          infinitive: "trouver",
          group: 1,
          present: {
            singular: ["trouve", "trouves", "trouve"],
            plural: ["trouvons", "trouvez", "trouvent"]
          }
        },
        "regarder": {
          infinitive: "regarder",
          group: 1,
          present: {
            singular: ["regarde", "regardes", "regarde"],
            plural: ["regardons", "regardez", "regardent"]
          }
        },
        "manger": {
          infinitive: "manger",
          group: 1,
          present: {
            singular: ["mange", "manges", "mange"],
            plural: ["mangeons", "mangez", "mangent"]
          }
        },
        
        // Deuxième groupe (-ir)
        "finir": {
          infinitive: "finir",
          group: 2,
          present: {
            singular: ["finis", "finis", "finit"],
            plural: ["finissons", "finissez", "finissent"]
          }
        },
        "choisir": {
          infinitive: "choisir",
          group: 2,
          present: {
            singular: ["choisis", "choisis", "choisit"],
            plural: ["choisissons", "choisissez", "choisissent"]
          }
        },
        
        // Troisième groupe (irréguliers)
        "faire": {
          infinitive: "faire",
          group: 3,
          present: {
            singular: ["fais", "fais", "fait"],
            plural: ["faisons", "faites", "font"]
          }
        },
        "dire": {
          infinitive: "dire",
          group: 3,
          present: {
            singular: ["dis", "dis", "dit"],
            plural: ["disons", "dites", "disent"]
          }
        },
        "venir": {
          infinitive: "venir",
          group: 3,
          present: {
            singular: ["viens", "viens", "vient"],
            plural: ["venons", "venez", "viennent"]
          }
        },
        "voir": {
          infinitive: "voir",
          group: 3,
          present: {
            singular: ["vois", "vois", "voit"],
            plural: ["voyons", "voyez", "voient"]
          }
        },
        "prendre": {
          infinitive: "prendre",
          group: 3,
          present: {
            singular: ["prends", "prends", "prend"],
            plural: ["prenons", "prenez", "prennent"]
          }
        },
        "aller": {
          infinitive: "aller",
          group: 3,
          present: {
            singular: ["vais", "vas", "va"],
            plural: ["allons", "allez", "vont"]
          }
        },
        
        // Verbes pronominaux
        "s'amuser": {
          infinitive: "s'amuser",
          group: 1,
          pronominal: true,
          present: {
            singular: ["m'amuse", "t'amuses", "s'amuse"],
            plural: ["nous amusons", "vous amusez", "s'amusent"]
          },
          // Formes détaillées pour l'analyse
          presentComponents: {
            singular: [
              { pronoun: "me", verb: "amuse" },
              { pronoun: "te", verb: "amuses" },
              { pronoun: "se", verb: "amuse" }
            ],
            plural: [
              { pronoun: "nous", verb: "amusons" },
              { pronoun: "vous", verb: "amusez" },
              { pronoun: "se", verb: "amusent" }
            ]
          }
        },
        "se lever": {
          infinitive: "se lever",
          group: 1,
          pronominal: true,
          present: {
            singular: ["me lève", "te lèves", "se lève"],
            plural: ["nous levons", "vous levez", "se lèvent"]
          },
          presentComponents: {
            singular: [
              { pronoun: "me", verb: "lève" },
              { pronoun: "te", verb: "lèves" },
              { pronoun: "se", verb: "lève" }
            ],
            plural: [
              { pronoun: "nous", verb: "levons" },
              { pronoun: "vous", verb: "levez" },
              { pronoun: "se", verb: "lèvent" }
            ]
          }
        }
      },
      
      // Terminaisons verbales par groupe
      verbEndings: {
        // Présent de l'indicatif
        indicativePresent: {
          firstGroup: {  // -er
            singular: ["e", "es", "e"],
            plural: ["ons", "ez", "ent"]
          },
          secondGroup: {  // -ir
            singular: ["is", "is", "it"],
            plural: ["issons", "issez", "issent"]
          },
          thirdGroup: {  // diverses, générales
            singular: ["s", "s", "t/d"],
            plural: ["ons", "ez", "ent"]
          }
        }
      },
      
      // Adjectifs communs
      commonAdjectives: [
        // Adjectifs de base
        "petit", "petite", "petits", "petites",
        "grand", "grande", "grands", "grandes",
        "beau", "belle", "beaux", "belles",
        "nouveau", "nouvelle", "nouveaux", "nouvelles",
        "vieux", "vieille", "vieux", "vieilles",
        "bon", "bonne", "bons", "bonnes",
        "mauvais", "mauvaise", "mauvais", "mauvaises",
        "joli", "jolie", "jolis", "jolies",
        "gros", "grosse", "gros", "grosses",
        
        // Adjectifs de couleur
        "blanc", "blanche", "blancs", "blanches",
        "noir", "noire", "noirs", "noires",
        "bleu", "bleue", "bleus", "bleues",
        "rouge", "rouges",
        "vert", "verte", "verts", "vertes",
        "jaune", "jaunes",
        "orange",
        "rose", "roses",
        "violet", "violette", "violets", "violettes",
        "gris", "grise", "gris", "grises",
        "marron",
        "brun", "brune", "bruns", "brunes"
      ],
      
      // Noms communs fréquents (liste partielle)
      commonNouns: [
        // Personnes
        "homme", "femme", "enfant", "garçon", "fille", "bébé", "adulte", 
        "ami", "amie", "amis", "amies", "famille", "mère", "père", "parent", "parents",
        "frère", "sœur", "fils", "fille", "oncle", "tante", "cousin", "cousine",
        "grand-père", "grand-mère", "grands-parents", "voisin", "voisine",
        
        // Objets
        "chose", "objet", "livre", "table", "chaise", "porte", "fenêtre", "lit",
        "stylo", "crayon", "papier", "journal", "magazine", "téléphone", "ordinateur",
        "voiture", "vélo", "train", "avion", "bateau", "bus", "métro",
        
        // Aliments (ajoutés pour l'exemple "Une pomme est mangée par elle")
        "pomme", "pommes", "fruit", "fruits", "légume", "légumes", "pain", "eau",
        
        // Lieux
        "maison", "appartement", "bureau", "école", "université", "entreprise",
        "magasin", "restaurant", "hôtel", "hôpital", "ville", "pays", "rue", "route",
        "place", "parc", "jardin", "forêt", "montagne", "plage", "mer", "océan", "rivière",
        
        // Concepts
        "temps", "heure", "minute", "seconde", "jour", "nuit", "matin", "soir",
        "semaine", "mois", "année", "siècle", "moment", "vie", "mort", "idée",
        "pensée", "sentiment", "émotion", "amour", "haine", "joie", "tristesse",
        "peur", "courage", "espoir", "rêve", "vérité", "mensonge", "problème", "solution",
        
        // Ajout spécifique pour les tests
        "enfants"
      ],
      
      // Indicateurs de voix passive
      passiveVoiceIndicators: [
        "est", "sont", "fut", "furent", 
        "était", "étaient", "sera", "seront",
        "a été", "ont été", "avait été", "avaient été"
      ],
      
      // Prépositions introduisant un complément d'agent
      agentPrepositions: ["par", "de"]
    };
    
    // Motifs grammaticaux (pour l'analyse en contexte)
    const grammarPatterns = {
      // Structure: déterminant + nom
      determinerNoun: {
        match: ["determiner", "noun"],
        example: "le chat"
      },
      
      // Structure: déterminant + adjectif + nom
      determinerAdjectiveNoun: {
        match: ["determiner", "adjective", "noun"],
        example: "la grande maison"
      },
      
      // Structure: déterminant + nom + adjectif
      determinerNounAdjective: {
        match: ["determiner", "noun", "adjective"],
        example: "le chat noir"
      },
      
      // Structure: pronom personnel sujet + verbe
      personalPronounVerb: {
        match: ["personal_pronoun_subject", "verb"],
        example: "je mange"
      },
      
      // Structure: verbe pronominal (pronom réfléchi + verbe)
      reflexivePronounVerb: {
        match: ["reflexive_pronoun", "verb"],
        example: "se laver"
      },
      
      // Structure: sujet + verbe
      subjectVerb: {
        match: ["noun|personal_pronoun_subject", "verb"],
        example: "l'enfant joue"
      },
      
      // Structure: verbe + complément d'objet direct
      verbDirectObject: {
        match: ["verb", "determiner", "noun"],
        example: "mange une pomme"
      },
      
      // Structure: voix passive
      passiveVoice: {
        match: ["determiner", "noun", "auxiliary", "pastParticiple", "preposition", "noun|pronoun"],
        example: "la pomme est mangée par lui"
      },
      
      // Structure simplifiée pour la voix passive
      simplePassiveVoice: {
        match: ["noun|pronoun", "auxiliary", "pastParticiple"],
        example: "le livre est lu"
      }
    };
    
    // Fonction pour tokeniser le texte
    function tokenizeText(text) {
      const tokens = [];
      
      // Prétraiter le texte pour gérer les élisions (mettre des espaces autour des apostrophes)
      let processedText = text.replace(/([a-zA-ZÀ-ÿ])'([a-zA-ZÀ-ÿ])/g, "$1' $2");
      
      // Prétraiter pour gérer les expressions composées (comme "parce que")
      const compoundExpressions = [
        "parce que", "bien que", "afin que", "pour que", "tandis que", "alors que",
        "il y a", "est-ce que", "c'est-à-dire", "d'après", "tout à fait", 
        "au-dessus", "au-dessous", "au lieu de", "en train de"
      ];
      
      // Découper le texte en tokens (mots et ponctuations)
      const rawTokens = processedText.match(/[a-zA-ZÀ-ÿ'']+|[.,!?;:()]/g) || [];
      
      // Traiter chaque token
      for (let i = 0; i < rawTokens.length; i++) {
        const token = rawTokens[i];
        
        // Ignorer les tokens vides
        if (!token.trim()) continue;
        
        // Traiter les signes de ponctuation
        if (/^[.,!?;:()]$/.test(token)) {
          tokens.push({ 
            original: token, 
            normalized: token, 
            type: "punctuation",
            position: tokens.length
          });
          continue;
        }
        
        // Traiter les élisions (j', l', etc.)
        if (token.endsWith("'")) {
          const elisionBase = token.slice(0, -1).toLowerCase();
          
          // Mapper les élisions courantes à leur forme complète
          let normalizedToken = elisionBase;
          if (elisionBase === "j") normalizedToken = "je";
          else if (elisionBase === "c") normalizedToken = "ce";
          else if (elisionBase === "s") normalizedToken = "se";
          else if (elisionBase === "d") normalizedToken = "de";
          else if (elisionBase === "l") normalizedToken = "le";
          else if (elisionBase === "m") normalizedToken = "me";
          else if (elisionBase === "n") normalizedToken = "ne";
          else if (elisionBase === "t") normalizedToken = "te";
          else if (elisionBase === "qu") normalizedToken = "que";
          
          tokens.push({
            original: token,
            normalized: normalizedToken,
            isElided: true,
            position: tokens.length
          });
          
          continue;
        }
        
        // Détecter si ce token fait partie d'une expression composée
        let isPartOfCompound = false;
        for (const expr of compoundExpressions) {
          const exprParts = expr.split(" ");
          if (i + exprParts.length <= rawTokens.length) {
            const potentialMatch = [];
            for (let j = 0; j < exprParts.length; j++) {
              potentialMatch.push(rawTokens[i + j].toLowerCase());
            }
            
            if (potentialMatch.join(" ") === expr) {
              tokens.push({
                original: potentialMatch.map((t, idx) => rawTokens[i + idx]).join(" "),
                normalized: expr,
                isCompound: true,
                componentCount: exprParts.length,
                position: tokens.length
              });
              
              // Avancer l'index pour sauter les tokens qui font partie de cette expression
              i += exprParts.length - 1;
              isPartOfCompound = true;
              break;
            }
          }
        }
        
        if (isPartOfCompound) continue;
        
        // Token standard
        tokens.push({
          original: token,
          normalized: token.toLowerCase(),
          position: tokens.length
        });
      }
      
      return tokens;
    }
    
    // Fonction principale d'analyse grammaticale
    function analyzeGrammar(tokens) {
      // Première étape: étiquetage morphologique initial (POS tagging)
      const taggedTokens = tokens.map((token, index) => {
        if (token.type === "punctuation") return token;
        
        // Analyse morphologique de base
        return {
          ...token,
          ...analyzeTokenType(token, tokens, index)
        };
      });
      
      // Deuxième étape: analyse syntaxique et résolution des ambiguïtés
      const analyzedTokens = syntacticAnalysis(taggedTokens);
      
      // Troisième étape: détection des structures spéciales (verbes pronominaux, voix passive, etc.)
      const structuredTokens = detectSpecialStructures(analyzedTokens);
      
      // Quatrième étape: identification des sujets, verbes et compléments
      return identifySentenceComponents(structuredTokens);
    }
    
    // Analyse morphologique (première étape)
    function analyzeTokenType(token, tokens, position) {
      const word = token.normalized;
      
      // 1. Détection des déterminants
      const determinerCheck = isDeterminer(word);
      if (determinerCheck) {
        return determinerCheck;
      }
      
      // 2. Détection des pronoms
      const pronounCheck = isPronoun(word);
      if (pronounCheck) {
        return pronounCheck;
      }
      
      // 3. Détection des verbes
      const verbCheck = isVerb(word, tokens, position);
      if (verbCheck) {
        return verbCheck;
      }
      
      // 4. Détection des prépositions
      if (frenchLexicon.prepositions.includes(word)) {
        return { type: "preposition" };
      }
      
      // 5. Détection des conjonctions
      if (frenchLexicon.coordinatingConjunctions.includes(word)) {
        return { type: "conjunction", subtype: "coordination" };
      }
      
      for (const subConj of frenchLexicon.subordinatingConjunctions) {
        if (word === subConj || word.startsWith(subConj + " ")) {
          return { type: "conjunction", subtype: "subordination" };
        }
      }
      
      // 6. Détection des adverbes
      if (frenchLexicon.commonAdverbs.includes(word)) {
        return { type: "adverb" };
      }
      
      // 7. Détection des mots de négation
      if (frenchLexicon.negationWords.includes(word)) {
        return { type: "negation" };
      }
      
      // 8. Détection des interjections
      if (frenchLexicon.interjections.includes(word)) {
        return { type: "interjection" };
      }
      
      // 9. Détection des noms communs connus
      if (frenchLexicon.commonNouns.includes(word)) {
        return { type: "noun", subtype: "common" };
      }
      
      // 10. Détection des adjectifs courants
      if (frenchLexicon.commonAdjectives.includes(word)) {
        return { type: "adjective", subtype: "qualificatif" };
      }
      
      // 11. Analyse contextuelle (utilisation du contexte pour déterminer la nature probable)
      const contextualCheck = analyzeByContext(word, tokens, position);
      if (contextualCheck) {
        return contextualCheck;
      }
      
      // 12. Analyse par terminaison (règles morphologiques)
      const suffixCheck = analyzeByEnding(word);
      if (suffixCheck) {
        return suffixCheck;
      }
      
      // Par défaut, probablement un nom (la catégorie la plus commune pour les mots inconnus)
      return { type: "noun", subtype: "indéterminé", confidence: "low" };
    }
    
    // Vérifier si le mot est un déterminant
    function isDeterminer(word) {
      // Articles définis
      if (frenchLexicon.definiteArticles.singular.includes(word) || 
          frenchLexicon.definiteArticles.plural.includes(word)) {
        return { type: "determiner", subtype: "article défini" };
      }
      
      // Articles indéfinis
      if (frenchLexicon.indefiniteArticles.singular.includes(word) || 
          frenchLexicon.indefiniteArticles.plural.includes(word)) {
        return { type: "determiner", subtype: "article indéfini" };
      }
      
      // Articles partitifs
      if (frenchLexicon.partitiveArticles.includes(word)) {
        return { type: "determiner", subtype: "article partitif" };
      }
      
      // Déterminants possessifs
      if (frenchLexicon.possessiveDeterminers.includes(word)) {
        return { type: "determiner", subtype: "possessif" };
      }
      
      // Déterminants démonstratifs
      if (frenchLexicon.demonstrativeDeterminers.includes(word)) {
        return { type: "determiner", subtype: "démonstratif" };
      }
      
      // Déterminants indéfinis
      if (frenchLexicon.indefiniteDeterminers.includes(word)) {
        return { type: "determiner", subtype: "indéfini" };
      }
      
      return null;
    }
    
    // Vérifier si le mot est un pronom
    function isPronoun(word) {
      // Pronoms personnels sujets
      if (frenchLexicon.personalPronouns.subject.includes(word)) {
        return { type: "pronoun", subtype: "personnel sujet" };
      }
      
      // Pronoms personnels compléments
      if (frenchLexicon.personalPronouns.object.includes(word)) {
        return { type: "pronoun", subtype: "personnel complément" };
      }
      
      // Pronoms personnels toniques
      if (frenchLexicon.personalPronouns.tonic.includes(word)) {
        return { type: "pronoun", subtype: "personnel tonique" };
      }
      
      // Pronoms réfléchis
      if (frenchLexicon.personalPronouns.reflexive.includes(word)) {
        return { type: "pronoun", subtype: "réfléchi" };
      }
      
      // Pronoms adverbiaux
      if (frenchLexicon.personalPronouns.adverbial.includes(word)) {
        return { type: "pronoun", subtype: "adverbial" };
      }
      
      // Pronoms démonstratifs
      if (frenchLexicon.demonstrativePronouns.includes(word)) {
        return { type: "pronoun", subtype: "démonstratif" };
      }
      
      // Pronoms relatifs
      if (frenchLexicon.relativePronouns.includes(word)) {
        return { type: "pronoun", subtype: "relatif" };
      }
      
      // Pronoms interrogatifs
      if (frenchLexicon.interrogativePronouns.includes(word)) {
        return { type: "pronoun", subtype: "interrogatif" };
      }
      
      // Pronoms indéfinis
      if (frenchLexicon.indefinitePronouns.includes(word)) {
        return { type: "pronoun", subtype: "indéfini" };
      }
      
      return null;
    }
    
    // Vérifier si le mot est un verbe (en utilisant le contexte)
    function isVerb(word, tokens, position) {
      // Vérifier dans le dictionnaire des verbes
      for (const [infinitive, verbData] of Object.entries(frenchLexicon.verbs)) {
        // Vérifier l'infinitif
        if (word === verbData.infinitive) {
          return { 
            type: "verb", 
            subtype: "infinitif", 
            infinitive: infinitive,
            group: verbData.group
          };
        }
        
        // Vérifier les formes conjuguées
        if (verbData.present) {
          // Singulier
          for (let i = 0; i < verbData.present.singular.length; i++) {
            if (word === verbData.present.singular[i]) {
              return { 
                type: "verb", 
                subtype: "indicatif présent", 
                person: i + 1, 
                number: "singular",
                infinitive: infinitive,
                group: verbData.group
              };
            }
          }
          
          // Pluriel
          for (let i = 0; i < verbData.present.plural.length; i++) {
            if (word === verbData.present.plural[i]) {
              return { 
                type: "verb", 
                subtype: "indicatif présent", 
                person: i + 1, 
                number: "plural",
                infinitive: infinitive,
                group: verbData.group
              };
            }
          }
        }
      }
      
      // Vérifier les verbes auxiliaires
      for (const [auxName, auxData] of Object.entries(frenchLexicon.auxiliaryVerbs)) {
        // Vérifier l'infinitif
        if (word === auxData.infinitive) {
          return { 
            type: "verb", 
            subtype: "auxiliaire", 
            infinitive: auxData.infinitive
          };
        }
        
        // Vérifier participe présent
        if (word === auxData.presentParticiple) {
          return { 
            type: "verb", 
            subtype: "participe présent", 
            infinitive: auxData.infinitive
          };
        }
        
        // Vérifier participe passé
        if (auxData.pastParticiple.includes(word)) {
          return { 
            type: "verb", 
            subtype: "participe passé", 
            infinitive: auxData.infinitive
          };
        }
        
        // Présent
        // Singulier
        for (let i = 0; i < auxData.present.singular.length; i++) {
          if (word === auxData.present.singular[i]) {
            return { 
              type: "verb", 
              subtype: "auxiliaire indicatif présent", 
              person: i + 1, 
              number: "singular",
              infinitive: auxData.infinitive,
              isAuxiliary: true
            };
          }
        }
        
        // Pluriel
        for (let i = 0; i < auxData.present.plural.length; i++) {
          if (word === auxData.present.plural[i]) {
            return { 
              type: "verb", 
              subtype: "auxiliaire indicatif présent", 
              person: i + 1, 
              number: "plural",
              infinitive: auxData.infinitive,
              isAuxiliary: true
            };
          }
        }
      }
      
      // Vérifier les terminaisons verbales typiques
      const verbDeduce = deduceVerbForm(word);
      if (verbDeduce.isVerb) {
        return {
          type: "verb",
          subtype: verbDeduce.tense,
          person: verbDeduce.person,
          number: verbDeduce.number,
          infinitive: verbDeduce.infinitive,
          group: verbDeduce.group,
          confidence: "medium"
        };
      }
      
      // Vérifier le contexte pour les verbes pronominaux
      // exemple: "s'amusent" peut être séparé en "s'" (pronom réfléchi) et "amusent" (verbe)
      if (position > 0) {
        const prevToken = tokens[position - 1];
        if (prevToken && prevToken.normalized === "s'" || prevToken.normalized === "se") {
          // Vérifier si ce mot pourrait être la partie verbale d'un verbe pronominal
          const verbStem = extractVerbStem(word);
          
          // Vérifier avec les terminaisons de l'indicatif présent, 3ème personne du pluriel
          if (word.endsWith("ent") && word.length > 3) {
            return {
              type: "verb",
              subtype: "indicatif présent (pronominal)",
              person: 3,
              number: "plural",
              infinitive: verbStem + "er", // Hypothèse du 1er groupe
              group: 1,
              reflexive: true,
              confidence: "high"
            };
          }
        }
      }
      
      // Détecter les participes passés
      if ((word.endsWith("é") || word.endsWith("i") || word.endsWith("u") || 
           word.endsWith("is") || word.endsWith("ée") || word.endsWith("és") || 
           word.endsWith("ées") || word.endsWith("ts") || word.endsWith("us") || 
           word.endsWith("ues")) && word.length > 2) {
        
        // Si le mot précédent est une forme d'être ou avoir, c'est probablement un participe passé
        if (position > 0) {
          const prevToken = tokens[position - 1];
          if (prevToken && isAuxiliaryVerb(prevToken.normalized)) {
            return {
              type: "verb",
              subtype: "participe passé",
              infinitive: deduceInfinitiveFromParticiple(word),
              confidence: "high",
              isPastParticiple: true
            };
          }
        }
        
        // Si pas précédé d'un auxiliaire mais a une forme de participe passé
        return {
          type: "verb",
          subtype: "participe passé",
          infinitive: deduceInfinitiveFromParticiple(word),
          confidence: "medium",
          isPastParticiple: true
        };
      }
      
      return null;
    }
    
    // Vérifier si un mot est un verbe auxiliaire
    function isAuxiliaryVerb(word) {
      // Formes d'être
      const etrePresent = ["suis", "es", "est", "sommes", "êtes", "sont"];
      const etreImperfect = ["étais", "était", "étions", "étiez", "étaient"];
      
      // Formes d'avoir
      const avoirPresent = ["ai", "as", "a", "avons", "avez", "ont"];
      const avoirImperfect = ["avais", "avait", "avions", "aviez", "avaient"];
      
      return etrePresent.includes(word) || etreImperfect.includes(word) || 
             avoirPresent.includes(word) || avoirImperfect.includes(word);
    }
    
    // Déduire l'infinitif à partir d'un participe passé
    function deduceInfinitiveFromParticiple(participle) {
      // Règles de base pour déduire l'infinitif à partir d'un participe passé
      const baseForm = participle.replace(/e?s$|e$|es$|ée?s?$/, "");
      
      if (participle.endsWith("é") || participle.endsWith("ée") || 
          participle.endsWith("és") || participle.endsWith("ées")) {
        return baseForm + "er"; // Premier groupe
      } else if (participle.endsWith("i") || participle.endsWith("ie") || 
                 participle.endsWith("is") || participle.endsWith("ies")) {
        return baseForm + "ir"; // Deuxième groupe ou troisième groupe
      } else if (participle.endsWith("u") || participle.endsWith("ue") || 
                 participle.endsWith("us") || participle.endsWith("ues")) {
        // Tenter de deviner pour les verbes du 3e groupe
        if (baseForm.endsWith("v")) return baseForm + "oir"; // ex: vu -> voir
        if (baseForm.endsWith("d")) return baseForm + "re"; // ex: rendu -> rendre
        return baseForm + "re"; // Hypothèse pour troisième groupe
      }
      
      return participle; // Par défaut
    }
    
    // Analyse par contexte
    function analyzeByContext(word, tokens, position) {
      // 1. Si précédé d'un déterminant, probablement un nom ou un adjectif
      if (position > 0) {
        const prevToken = tokens[position - 1];
        if (prevToken && isDeterminer(prevToken.normalized)) {
          // Si suivi d'un mot qui est clairement un nom, probablement un adjectif
          if (position < tokens.length - 1) {
            const nextToken = tokens[position + 1];
            if (nextToken && frenchLexicon.commonNouns.includes(nextToken.normalized)) {
              return { type: "adjective", subtype: "qualificatif", position: "avant le nom", confidence: "medium" };
            }
          }
          
          // Sinon, probablement un nom
          return { type: "noun", subtype: "commun", confidence: "medium" };
        }
      }
      
      // 2. Si précédé d'un pronom personnel sujet, probablement un verbe
      if (position > 0) {
        const prevToken = tokens[position - 1];
        if (prevToken && frenchLexicon.personalPronouns.subject.includes(prevToken.normalized)) {
          return { type: "verb", subtype: "indicatif présent", confidence: "medium" };
        }
      }
      
      // 3. Si précédé d'une préposition, probablement un nom
      if (position > 0) {
        const prevToken = tokens[position - 1];
        if (prevToken && frenchLexicon.prepositions.includes(prevToken.normalized)) {
          return { type: "noun", subtype: "commun", confidence: "medium" };
        }
      }
      
      // 4. Détection des verbes pronominaux ("s'amusent", etc.)
      if (position > 0) {
        const prevToken = tokens[position - 1];
        // Si précédé de "s'" ou "se", probablement partie d'un verbe pronominal
        if (prevToken && (prevToken.normalized === "se" || prevToken.normalized === "s'")) {
          // Vérifier les terminaisons verbales
          if (word.endsWith("e") || word.endsWith("es") || word.endsWith("ons") || 
              word.endsWith("ez") || word.endsWith("ent")) {
            return { 
              type: "verb", 
              subtype: "indicatif présent (pronominal)", 
              confidence: "high"
            };
          }
        }
      }
      
      // 5. Détecter les structures de voix passive
      if (position > 0 && position < tokens.length - 1) {
        const prevToken = tokens[position - 1];
        const nextToken = tokens[position + 1];
        
        // Si le mot est "est" ou une autre forme d'être et est suivi d'un possible participe passé
        if (frenchLexicon.auxiliaryVerbs.être.present.singular.includes(word) ||
            frenchLexicon.auxiliaryVerbs.être.present.plural.includes(word)) {
          
          // Vérifier si le token suivant est potentiellement un participe passé
          if (nextToken && 
              (nextToken.normalized.endsWith("é") || 
               nextToken.normalized.endsWith("ie") || 
               nextToken.normalized.endsWith("is") || 
               nextToken.normalized.endsWith("u") || 
               nextToken.normalized.endsWith("ée") || 
               nextToken.normalized.endsWith("és") || 
               nextToken.normalized.endsWith("ées"))) {
            
            return { 
              type: "verb", 
              subtype: "auxiliaire (voix passive)", 
              confidence: "high",
              isAuxiliary: true,
              role: "auxiliaire passive"
            };
          }
        }
      }
      
      return null;
    }
    
    // Analyse par terminaison (suffixes)
    function analyzeByEnding(word) {
      // 1. Terminaisons nominales
      const nominalEndings = [
        { suffix: "tion", type: "noun", gender: "feminine" },
        { suffix: "sion", type: "noun", gender: "feminine" },
        { suffix: "té", type: "noun", gender: "feminine" },
        { suffix: "ité", type: "noun", gender: "feminine" },
        { suffix: "isme", type: "noun", gender: "masculine" },
        { suffix: "age", type: "noun", gender: "masculine" },
        { suffix: "ment", type: "noun", gender: "masculine" },
        { suffix: "eur", type: "noun", gender: "masculine" },
        { suffix: "esse", type: "noun", gender: "feminine" },
        { suffix: "ette", type: "noun", gender: "feminine" },
        { suffix: "ie", type: "noun", gender: "feminine" },
        { suffix: "erie", type: "noun", gender: "feminine" },
        { suffix: "ance", type: "noun", gender: "feminine" },
        { suffix: "ence", type: "noun", gender: "feminine" },
        { suffix: "tude", type: "noun", gender: "feminine" },
        { suffix: "ade", type: "noun", gender: "feminine" },
        { suffix: "ure", type: "noun", gender: "feminine" },
        { suffix: "oir", type: "noun", gender: "masculine" },
        { suffix: "oire", type: "noun", gender: "feminine" }
      ];
      
      // 2. Terminaisons adjectivales
      const adjectivalEndings = [
        { suffix: "able", type: "adjective" },
        { suffix: "ible", type: "adjective" },
        { suffix: "eux", type: "adjective" },
        { suffix: "euse", type: "adjective" },
        { suffix: "if", type: "adjective" },
        { suffix: "ive", type: "adjective" },
        { suffix: "al", type: "adjective" },
        { suffix: "ale", type: "adjective" },
        { suffix: "el", type: "adjective" },
        { suffix: "elle", type: "adjective" },
        { suffix: "ique", type: "adjective" },
        { suffix: "aire", type: "adjective" },
        { suffix: "ien", type: "adjective" },
        { suffix: "ienne", type: "adjective" },
        { suffix: "ois", type: "adjective" },
        { suffix: "oise", type: "adjective" },
        { suffix: "ain", type: "adjective" },
        { suffix: "aine", type: "adjective" },
        { suffix: "ard", type: "adjective" },
        { suffix: "arde", type: "adjective" },
        { suffix: "ent", type: "adjective" },
        { suffix: "ente", type: "adjective" },
        { suffix: "escent", type: "adjective" },
        { suffix: "escente", type: "adjective" }
      ];
      
      // 3. Terminaisons adverbiales
      const adverbialEndings = [
        { suffix: "ment", type: "adverb" }
      ];
      
      // 4. Terminaisons verbales (infinitif)
      const verbalEndings = [
        { suffix: "er", type: "verb", subtype: "infinitif", group: 1 },
        { suffix: "ir", type: "verb", subtype: "infinitif", group: 2 },
        { suffix: "re", type: "verb", subtype: "infinitif", group: 3 },
        { suffix: "oir", type: "verb", subtype: "infinitif", group: 3 }
      ];
      
      // Vérifier les terminaisons dans l'ordre: adjectival, nominal, adverbial, verbal
      // Car certaines terminaisons peuvent être ambiguës (ex: "ment" peut être nominal ou adverbial)
      
      // Vérifier terminaisons adjectivales
      for (const ending of adjectivalEndings) {
        if (word.endsWith(ending.suffix) && word.length > ending.suffix.length + 1) {
          return { type: "adjective", subtype: "qualificatif", confidence: "medium" };
        }
      }
      
      // Vérifier terminaisons nominales
      for (const ending of nominalEndings) {
        if (word.endsWith(ending.suffix) && word.length > ending.suffix.length + 1) {
          return { type: "noun", subtype: "commun", gender: ending.gender, confidence: "medium" };
        }
      }
      
      // Vérifier terminaisons adverbiales (sauf celles qui sont aussi nominales)
      for (const ending of adverbialEndings) {
        // Vérifier que ce n'est pas un nom se terminant par "ment"
        if (word.endsWith(ending.suffix) && word.length > ending.suffix.length + 2 &&
            !word.endsWith("ement") && !word.endsWith("issement")) {
          return { type: "adverb", confidence: "medium" };
        }
      }
      
      // Vérifier terminaisons verbales
      for (const ending of verbalEndings) {
        // Éviter les faux positifs (noms se terminant par -er comme "dossier")
        const exceptions = ["dossier", "cahier", "papier", "tablier", "pilier", "escalier", "métier"];
        if (word.endsWith(ending.suffix) && word.length > ending.suffix.length + 1 &&
            !exceptions.includes(word)) {
          return { 
            type: "verb", 
            subtype: ending.subtype, 
            group: ending.group,
            infinitive: word,
            confidence: "medium" 
          };
        }
      }
      
      return null;
    }
    
    // Déduire la forme verbale à partir de la terminaison
    function deduceVerbForm(word) {
      // Terminaisons du présent de l'indicatif
      const presentEndings = {
        firstGroup: {
          singular: ["e", "es", "e"],
          plural: ["ons", "ez", "ent"]
        },
        secondGroup: {
          singular: ["is", "is", "it"],
          plural: ["issons", "issez", "issent"]
        }
      };
      
      // Vérifier les terminaisons du premier groupe (-er)
      // Singulier
      for (let i = 0; i < presentEndings.firstGroup.singular.length; i++) {
        const ending = presentEndings.firstGroup.singular[i];
        if (word.endsWith(ending) && word.length > ending.length + 1) {
          const stem = word.slice(0, word.length - ending.length);
          return {
            isVerb: true,
            tense: "indicatif présent",
            person: i + 1,
            number: "singular",
            infinitive: stem + "er",
            group: 1
          };
        }
      }
      
      // Pluriel
      for (let i = 0; i < presentEndings.firstGroup.plural.length; i++) {
        const ending = presentEndings.firstGroup.plural[i];
        if (word.endsWith(ending) && word.length > ending.length + 1) {
          const stem = word.slice(0, word.length - ending.length);
          return {
            isVerb: true,
            tense: "indicatif présent",
            person: i + 1,
            number: "plural",
            infinitive: stem + "er",
            group: 1
          };
        }
      }
      
      // Vérifier les terminaisons du deuxième groupe (-ir)
      // Singulier
      for (let i = 0; i < presentEndings.secondGroup.singular.length; i++) {
        const ending = presentEndings.secondGroup.singular[i];
        if (word.endsWith(ending) && word.length > ending.length + 1) {
          const stem = word.slice(0, word.length - ending.length);
          return {
            isVerb: true,
            tense: "indicatif présent",
            person: i + 1,
            number: "singular",
            infinitive: stem + "ir",
            group: 2
          };
        }
      }
      
      // Pluriel
      for (let i = 0; i < presentEndings.secondGroup.plural.length; i++) {
        const ending = presentEndings.secondGroup.plural[i];
        if (word.endsWith(ending) && word.length > ending.length + 1) {
          // On retire "-iss" pour obtenir le radical
          const stem = word.slice(0, word.length - ending.length);
          return {
            isVerb: true,
            tense: "indicatif présent",
            person: i + 1,
            number: "plural",
            infinitive: stem + "ir",
            group: 2
          };
        }
      }
      
      // Terminaisons pour le participe présent (-ant)
      if (word.endsWith("ant") && word.length > 4) {
        const stem = word.slice(0, word.length - 3);
        return {
          isVerb: true,
          tense: "participe présent",
          infinitive: stem + "er", // Hypothèse
          group: 1 // Hypothèse
        };
      }
      
      // Terminaisons pour le participe passé (-é, -ée, -és, -ées)
      if ((word.endsWith("é") || word.endsWith("ée") || word.endsWith("és") || word.endsWith("ées")) && word.length > 2) {
        const stem = word.slice(0, word.length - (word.endsWith("é") ? 1 : (word.endsWith("és") || word.endsWith("ée") ? 2 : 3)));
        return {
          isVerb: true,
          tense: "participe passé",
          infinitive: stem + "er",
          group: 1,
          isPastParticiple: true
        };
      }
      
      return { isVerb: false };
    }
    
    // Fonction pour analyser le texte en recherchant les verbes pronominaux
    function detectVerbPronominal(tokens, startIndex) {
      if (startIndex >= tokens.length - 1) return null;
      
      const currentToken = tokens[startIndex];
      const nextToken = tokens[startIndex + 1];
      
      // Vérifier si le token actuel est un pronom réfléchi
      if (currentToken.type === "pronoun" && 
          (currentToken.subtype === "réfléchi" || currentToken.normalized === "se" || currentToken.normalized === "s'")) {
        
        // Vérifier si le token suivant est un verbe ou peut être analysé comme un verbe
        if (nextToken.type === "verb" || (nextToken.type === "adjective" && nextToken.normalized.endsWith("ent"))) {
          // Créer une structure de verbe pronominal
          return {
            start: startIndex,
            end: startIndex + 1,
            type: "verb_pronominal",
            components: [
              { ...currentToken, role: "reflexive_pronoun" },
              { ...nextToken, type: "verb", role: "verb_component", subtype: "indicatif présent" }
            ]
          };
        }
      }
      
      return null;
    }
    
    // Détection de voix passive
    function detectPassiveVoice(tokens, startIndex) {
      // Il faut au moins 3 tokens pour une voix passive minimale: sujet + être + participe passé
      if (startIndex + 2 >= tokens.length) return null;
      
      // Vérifier si on a un auxiliaire être suivi d'un participe passé
      let auxIndex = -1;
      let participleIndex = -1;
      
      // Rechercher l'auxiliaire être
      for (let i = startIndex; i < tokens.length - 1; i++) {
        if (tokens[i].type === "verb" && tokens[i].isAuxiliary && 
            tokens[i].infinitive === "être") {
          auxIndex = i;
          
          // Rechercher le participe passé après l'auxiliaire
          for (let j = i + 1; j < tokens.length; j++) {
            if (tokens[j].type === "verb" && tokens[j].isPastParticiple) {
              participleIndex = j;
              break;
            }
          }
          
          break;
        }
      }
      
      if (auxIndex !== -1 && participleIndex !== -1) {
        // Rechercher un potentiel complément d'agent introduit par "par" ou "de"
        let agentIndex = -1;
        let prepositionIndex = -1;
        
        for (let i = participleIndex + 1; i < tokens.length; i++) {
          if (tokens[i].type === "preposition" && 
              frenchLexicon.agentPrepositions.includes(tokens[i].normalized)) {
            prepositionIndex = i;
            
            // Chercher le complément d'agent après la préposition
            if (i + 1 < tokens.length && 
                (tokens[i+1].type === "noun" || tokens[i+1].type === "pronoun")) {
              agentIndex = i + 1;
              break;
            }
          }
        }
        
        // Structure de voix passive trouvée
        return {
          type: "passive_voice",
          auxiliaryIndex: auxIndex,
          participleIndex: participleIndex,
          prepositionIndex: prepositionIndex !== -1 ? prepositionIndex : null,
          agentIndex: agentIndex !== -1 ? agentIndex : null,
          // Le sujet est généralement avant l'auxiliaire
          subjectIndices: findSubjectBeforeIndex(tokens, auxIndex)
        };
      }
      
      return null;
    }
    
    // Trouver le sujet avant un certain indice
    function findSubjectBeforeIndex(tokens, endIndex) {
      // Le sujet peut être un groupe nominal ou un pronom
      const subjectIndices = [];
      
      for (let i = 0; i < endIndex; i++) {
        // Si c'est un pronom sujet
        if (tokens[i].type === "pronoun" && tokens[i].subtype === "personnel sujet") {
          subjectIndices.push(i);
        }
        // Si c'est un nom précédé d'un déterminant (groupe nominal)
        else if (tokens[i].type === "noun" && i > 0 && tokens[i-1].type === "determiner") {
          subjectIndices.push(i-1, i); // Inclure le déterminant et le nom
          
          // Inclure aussi les adjectifs qui qualifient ce nom
          let j = i + 1;
          while (j < endIndex && tokens[j].type === "adjective") {
            subjectIndices.push(j);
            j++;
          }
        }
      }
      
      return subjectIndices;
    }
    
    // Extraction du radical verbal (pour les verbes pronominaux)
    function extractVerbStem(word) {
      // Enlever les terminaisons communes pour trouver le radical
      if (word.endsWith("ent")) return word.slice(0, word.length - 3);
      if (word.endsWith("ez")) return word.slice(0, word.length - 2);
      if (word.endsWith("ons")) return word.slice(0, word.length - 3);
      if (word.endsWith("e") || word.endsWith("es")) return word.slice(0, word.length - 1);
      
      return word; // Par défaut
    }
    
    // Analyse syntaxique et résolution des ambiguïtés
    function syntacticAnalysis(tokens) {
      const analyzed = [...tokens];
      
      // Parcourir les tokens pour résoudre les ambiguïtés
      for (let i = 0; i < analyzed.length; i++) {
        if (analyzed[i].type === "punctuation") continue;
        
        // Résoudre les ambiguïtés articles/pronoms ("le", "la", "les")
        if (analyzed[i].normalized === "le" || analyzed[i].normalized === "la" || analyzed[i].normalized === "les") {
          // Si suivi d'un nom ou adjectif, c'est un article
          if (i < analyzed.length - 1 && 
              (analyzed[i+1].type === "noun" || analyzed[i+1].type === "adjective")) {
            analyzed[i].type = "determiner";
            analyzed[i].subtype = "article défini";
          }
          // Sinon c'est probablement un pronom
          else {
            analyzed[i].type = "pronoun";
            analyzed[i].subtype = "personnel complément";
          }
        }
        
        // Résoudre les ambiguïtés pour les pronoms réfléchis dans les verbes pronominaux
        if (analyzed[i].normalized === "se" || analyzed[i].normalized === "s'") {
          // Si suivi d'un mot qui pourrait être un verbe
          if (i < analyzed.length - 1) {
            const nextToken = analyzed[i+1];
            // Si déjà identifié comme verbe ou si a une terminaison verbale
            if (nextToken.type === "verb" || 
                (nextToken.normalized.endsWith("e") || nextToken.normalized.endsWith("es") || 
                 nextToken.normalized.endsWith("ent"))) {
              
              analyzed[i].type = "pronoun";
              analyzed[i].subtype = "réfléchi";
              analyzed[i].role = "pronom réfléchi (verbe pronominal)";
              
              // Assurer que le token suivant est identifié comme verbe
              if (nextToken.type !== "verb") {
                analyzed[i+1].type = "verb";
                analyzed[i+1].subtype = "indicatif présent";
                analyzed[i+1].role = "composante verbale (verbe pronominal)";
              }
            }
          }
        }
        
        // Correction pour les adjectifs qui suivent un déterminant et précèdent un nom
        if (analyzed[i].type === "adjective" && i > 0 && i < analyzed.length - 1) {
          const prevToken = analyzed[i-1];
          const nextToken = analyzed[i+1];
          
          if (prevToken.type === "determiner" && nextToken.type === "noun") {
            analyzed[i].position = "avant le nom";
            analyzed[i].pattern = "déterminant + adjectif + nom";
          }
        }
        
        // Correction pour les mots qui ne devraient pas être des adjectifs après un déterminant
        if (analyzed[i].type === "adjective" && i > 0) {
          const prevToken = analyzed[i-1];
          
          if (prevToken.type === "determiner" && 
              !frenchLexicon.commonAdjectives.includes(analyzed[i].normalized) && 
              i === analyzed.length - 1) {
            // Si c'est le dernier mot après un déterminant et pas un adjectif reconnu
            analyzed[i].type = "noun";
            analyzed[i].subtype = "commun";
            delete analyzed[i].position;
          }
        }
        
        // Amélioration de la détection des auxiliaires pour la voix passive
        if (analyzed[i].type === "verb" && 
            (analyzed[i].infinitive === "être" || 
             analyzed[i].normalized === "est" || 
             analyzed[i].normalized === "sont")) {
          
          // Vérifier si suivi d'un participe passé
          if (i < analyzed.length - 1) {
            const nextToken = analyzed[i+1];
            if (nextToken.type === "verb" && 
                (nextToken.subtype === "participe passé" || nextToken.isPastParticiple)) {
              analyzed[i].isAuxiliary = true;
              analyzed[i].role = "auxiliaire (voix passive)";
            }
          }
        }
      }
      
      return analyzed;
    }
    
    // Détection des structures grammaticales spéciales
    function detectSpecialStructures(tokens) {
      const result = [...tokens];
      let i = 0;
      
      while (i < result.length) {
        // Détecter les verbes pronominaux
        const verbPronominal = detectVerbPronominal(result, i);
        if (verbPronominal) {
          // Marquer le pronom réfléchi
          result[i].role = "pronom réfléchi";
          result[i].verbPronominalPart = true;
          
          // Marquer le verbe
          result[i+1].type = "verb";
          result[i+1].subtype = "indicatif présent";
          result[i+1].verbPronominalPart = true;
          result[i+1].role = "composante verbale";
          
          // Sauter le token suivant qui fait partie du verbe pronominal
          i += 2;
          continue;
        }
        
        // Détecter et corriger les "il y a" (locution verbale)
        if (i < result.length - 2 && 
            result[i].normalized === "il" && 
            result[i+1].normalized === "y" && 
            result[i+2].normalized === "a") {
          
          result[i].role = "composante de locution verbale";
          result[i+1].role = "composante de locution verbale";
          result[i+2].role = "composante de locution verbale";
          
          i += 3;
          continue;
        }
        
        i++;
      }
      
      // Détection de voix passive dans l'ensemble de la phrase
      const passiveVoice = detectPassiveVoice(result, 0);
      if (passiveVoice) {
        // Marquer l'auxiliaire
        result[passiveVoice.auxiliaryIndex].role = "auxiliaire (voix passive)";
        
        // Marquer le participe passé
        result[passiveVoice.participleIndex].role = "participe passé (voix passive)";
        
        // Marquer le complément d'agent si présent
        if (passiveVoice.prepositionIndex !== null) {
          result[passiveVoice.prepositionIndex].role = "préposition (complément d'agent)";
        }
        
        if (passiveVoice.agentIndex !== null) {
          result[passiveVoice.agentIndex].role = "complément d'agent";
          result[passiveVoice.agentIndex].isAgent = true;
        }
        
        // Marquer le sujet
        passiveVoice.subjectIndices.forEach(index => {
          result[index].isPassiveSubject = true;
          if (result[index].type === "noun") {
            result[index].role = "sujet (patient)";
          } else if (result[index].type === "determiner") {
            result[index].role = "déterminant du sujet";
          }
        });
      }
      
      return result;
    }
    
    // Identification des sujets, verbes et compléments dans la phrase
    function identifySentenceComponents(tokens) {
      const result = [...tokens];
      let mainVerb = null;
      let mainVerbIndex = -1;
      
      // Première étape: identifier le verbe principal
      for (let i = 0; i < result.length; i++) {
        if (result[i].type === "verb" && !result[i].isAuxiliary && 
            !result[i].isPastParticiple && !result[i].verbPronominalPart) {
          mainVerb = result[i];
          mainVerbIndex = i;
          mainVerb.role = "verbe principal";
          break;
        }
      }
      
      // Si pas de verbe principal trouvé, chercher un verbe pronominal
      if (mainVerbIndex === -1) {
        for (let i = 0; i < result.length - 1; i++) {
          if (result[i].type === "pronoun" && result[i].subtype === "réfléchi" &&
              result[i+1].type === "verb") {
            mainVerb = result[i+1];
            mainVerbIndex = i+1;
            mainVerb.role = "verbe principal (pronominal)";
            result[i].role = "pronom réfléchi du verbe principal";
            break;
          }
        }
      }
      
      // Si toujours pas de verbe principal, chercher un auxiliaire + participe passé
      if (mainVerbIndex === -1) {
        for (let i = 0; i < result.length - 1; i++) {
          if (result[i].type === "verb" && result[i].isAuxiliary &&
              i+1 < result.length && result[i+1].type === "verb" && result[i+1].isPastParticiple) {
            mainVerb = result[i+1];
            mainVerbIndex = i+1;
            mainVerb.role = "participe passé du verbe principal";
            result[i].role = "auxiliaire du verbe principal";
            break;
          }
        }
      }
      
      // Si on a trouvé un verbe principal, chercher son sujet et ses compléments
      if (mainVerbIndex !== -1) {
        // Chercher le sujet (avant le verbe principal)
        let subjectFound = false;
        
        // Cas 1: Pronom personnel sujet juste avant le verbe
        if (mainVerbIndex > 0 && 
            result[mainVerbIndex-1].type === "pronoun" && 
            result[mainVerbIndex-1].subtype === "personnel sujet") {
          result[mainVerbIndex-1].role = "sujet";
          result[mainVerbIndex-1].isSubject = true;
          subjectFound = true;
        }
        // Cas 2: Chercher un groupe nominal (déterminant + nom)
        else {
          for (let i = 0; i < mainVerbIndex; i++) {
            if (result[i].type === "noun" && i > 0 && result[i-1].type === "determiner") {
              result[i].role = "sujet";
              result[i].isSubject = true;
              result[i-1].role = "déterminant du sujet";
              
              // Vérifier s'il y a des adjectifs après le nom
              let j = i + 1;
              while (j < mainVerbIndex && result[j].type === "adjective") {
                result[j].role = "adjectif du sujet";
                j++;
              }
              
              subjectFound = true;
              break;
            }
          }
        }
        
        // Si on n'a pas trouvé de sujet standard, vérifier s'il s'agit d'une voix passive
        if (!subjectFound) {
          for (let i = 0; i < result.length; i++) {
            if (result[i].isPassiveSubject) {
              subjectFound = true;
              break;
            }
          }
        }
        
        // Chercher un complément d'objet direct après le verbe
        let objectFound = false;
        
        // Cas 1: Pronom personnel complément avant le verbe
        for (let i = 0; i < mainVerbIndex; i++) {
          if (result[i].type === "pronoun" && result[i].subtype === "personnel complément") {
            result[i].role = "complément d'objet direct";
            result[i].isObject = true;
            objectFound = true;
            break;
          }
        }
        
        // Cas 2: Groupe nominal après le verbe
        if (!objectFound) {
          for (let i = mainVerbIndex + 1; i < result.length; i++) {
            if (result[i].type === "noun" && i > 0 && result[i-1].type === "determiner") {
              // Vérifier qu'il n'est pas déjà identifié comme agent dans une voix passive
              if (!result[i].isAgent) {
                result[i].role = "complément d'objet direct";
                result[i].isObject = true;
                result[i-1].role = "déterminant du COD";
                
                // Vérifier s'il y a des adjectifs après le nom
                let j = i + 1;
                while (j < result.length && result[j].type === "adjective") {
                  result[j].role = "adjectif du COD";
                  j++;
                }
                
                objectFound = true;
                break;
              }
            }
          }
        }
      }
      
      return result;
    }
    
    // Regrouper les résultats par catégorie grammaticale
    function categorizeResults(analyzedTokens) {
      const categories = {
        pronoun: [],
        verb: [],
        noun: [],
        adjective: [],
        determiner: [],
        adverb: [],
        preposition: [],
        conjunction: [],
        negation: [],
        interjection: []
      };
      
      analyzedTokens.forEach(token => {
        if (token.type === "punctuation") return;
        
        if (token.type in categories) {
          // Éviter les doublons dans chaque catégorie
          const exists = categories[token.type].some(item => 
            item.normalized === token.normalized
          );
          
          if (!exists) {
            categories[token.type].push(token);
          }
        }
      });
      
      return categories;
    }
    
    // Analyser la structure de la phrase
    function analyzeSentenceStructure(analyzedTokens) {
      // Détecter si la phrase est active ou passive
      let isPassive = false;
      let mainVerb = null;
      let subject = null;
      let object = null;
      let agent = null;
      
      // Trouver le sujet, le verbe principal et l'objet
      analyzedTokens.forEach(token => {
        if (token.isSubject) subject = token;
        if (token.role === "verbe principal" || token.role === "participe passé du verbe principal") mainVerb = token;
        if (token.isObject) object = token;
        if (token.isAgent) agent = token;
        if (token.role === "auxiliaire (voix passive)") isPassive = true;
      });
      
      // Déterminer le type de phrase
      let sentenceType = "déclarative";
      if (analyzedTokens.length > 0 && analyzedTokens[analyzedTokens.length - 1].original === "?") {
        sentenceType = "interrogative";
      } else if (analyzedTokens.length > 0 && analyzedTokens[analyzedTokens.length - 1].original === "!") {
        sentenceType = "exclamative";
      }
      
      // Déterminer le type de construction (active, passive, etc.)
      let constructionType = isPassive ? "passive" : "active";
      
      return {
        type: sentenceType,
        construction: constructionType,
        subject: subject ? subject.original : "non identifié",
        mainVerb: mainVerb ? mainVerb.original : "non identifié", 
        object: object ? object.original : (isPassive ? "sujet de la voix passive" : "non identifié"),
        agent: agent ? agent.original : "non identifié"
      };
    }
    
    // Générer le HTML pour afficher une catégorie grammaticale
    function generateCategoryHTML(category, items) {
      if (!items || items.length === 0) return '';
      
      let html = `
        <div class="category-header">
          <div class="category-badge ${category}-badge">${categoryNames[category]}</div>
          <div class="category-description">${categoryDescriptions[category]}</div>
        </div>
        <div class="category-content">
      `;
      
      items.forEach(item => {
        let displayText = item.original;
        
        // Ajouter des informations pertinentes selon la catégorie
        if (category === "verb") {
          if (item.infinitive) {
            displayText = `${item.original}`;
            if (item.infinitive !== item.original.toLowerCase()) {
              displayText += ` [${item.infinitive}`;
              if (item.subtype && item.subtype !== "infinitif") {
                displayText += ` (${item.subtype})`;
              }
              displayText += `]`;
            }
          }
        } 
        else if (item.role) {
          displayText = `${item.original} [${item.role}]`;
        }
        
        html += `<span class="word-tag ${category} tooltip">${displayText}<span class="tooltip-text">${categoryNames[category]}${item.subtype ? ` ${item.subtype}` : ''}</span></span>`;
      });
      
      html += `
        </div>
      `;
      
      return html;
    }
    
    // Formatter le texte analysé en HTML avec des étiquettes de couleur
    function formatAnalyzedText(analyzedTokens) {
      let html = '';
      
      analyzedTokens.forEach(token => {
        if (token.type === "punctuation") {
          html += token.original;
        } else {
          let cssClasses = `word-tag ${token.type} tooltip`;
          
          // Ajouter des classes spéciales pour les sujets et objets
          if (token.isSubject || token.isPassiveSubject) cssClasses += ' subject';
          if (token.isObject) cssClasses += ' object';
          
          const tooltipContent = `${categoryNames[token.type]}${token.subtype ? ` ${token.subtype}` : ''}${token.role ? `<br>Rôle: ${token.role}` : ''}`;
          
          html += `<span class="${cssClasses}">${token.original}<span class="tooltip-text">${tooltipContent}</span></span> `;
        }
      });
      
      return html;
    }
    
    // Générer le HTML pour afficher la structure de la phrase
    function generateStructureHTML(structure) {
      return `
        <div class="sentence-structure">
          <div class="structure-title">ANALYSE DE STRUCTURE</div>
          <div class="structure-item">
            <div class="structure-label">Type:</div>
            <div class="structure-value">Phrase ${structure.type}</div>
          </div>
          <div class="structure-item">
            <div class="structure-label">Construction:</div>
            <div class="structure-value">Voix ${structure.construction}</div>
          </div>
          <div class="structure-item">
            <div class="structure-label">Sujet:</div>
            <div class="structure-value">${structure.subject}</div>
          </div>
          <div class="structure-item">
            <div class="structure-label">Verbe:</div>
            <div class="structure-value">${structure.mainVerb}</div>
          </div>
          ${structure.construction === "passive" ? `
          <div class="structure-item">
            <div class="structure-label">Patient:</div>
            <div class="structure-value">${structure.subject}</div>
          </div>
          <div class="structure-item">
            <div class="structure-label">Agent:</div>
            <div class="structure-value">${structure.agent !== "non identifié" ? structure.agent : "non spécifié"}</div>
          </div>
          ` : `
          <div class="structure-item">
            <div class="structure-label">Objet:</div>
            <div class="structure-value">${structure.object !== "non identifié" ? structure.object : "non spécifié"}</div>
          </div>
          `}
        </div>
      `;
    }
    
    // Obtenir l'heure actuelle formatée
    function getCurrentTime() {
      const now = new Date();
      let hours = now.getHours();
      let minutes = now.getMinutes();
      
      // Ajouter un 0 devant les chiffres < 10
      hours = hours < 10 ? '0' + hours : hours;
      minutes = minutes < 10 ? '0' + minutes : minutes;
      
      return `${hours}:${minutes}`;
    }
    
    // Ajouter un message utilisateur au chat
    function addUserMessage(text) {
      const chatContainer = document.getElementById('chatContainer');
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message user';
      messageDiv.innerHTML = `
        <div class="message-content">${text}</div>
        <div class="message-time">${getCurrentTime()}</div>
      `;
      
      chatContainer.appendChild(messageDiv);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }
    
    // Ajouter un indicateur de saisie
    function addTypingIndicator() {
      const chatContainer = document.getElementById('chatContainer');
      const typingDiv = document.createElement('div');
      typingDiv.className = 'typing-indicator';
      typingDiv.id = 'typingIndicator';
      typingDiv.innerHTML = `
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
      `;
      
      chatContainer.appendChild(typingDiv);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }
    
    // Supprimer l'indicateur de saisie
    function removeTypingIndicator() {
      const typingIndicator = document.getElementById('typingIndicator');
      if (typingIndicator) {
        typingIndicator.remove();
      }
    }
    
    // Ajouter un message bot au chat
    function addBotMessage(content) {
      removeTypingIndicator();
      
      const chatContainer = document.getElementById('chatContainer');
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message bot';
      messageDiv.innerHTML = `
        <div class="message-content">${content}</div>
        <div class="message-time">${getCurrentTime()}</div>
      `;
      
      chatContainer.appendChild(messageDiv);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }
    
    // Fonction principale pour analyser la phrase
    function analyzeSentence(text) {
      try {
        // Tokeniser le texte
        const tokens = tokenizeText(text);
        
        // Analyser la grammaire
        const analyzedTokens = analyzeGrammar(tokens);
        
        // Analyser la structure de la phrase
        const sentenceStructure = analyzeSentenceStructure(analyzedTokens);
        
        // Regrouper les résultats par catégorie
        const categorizedResults = categorizeResults(analyzedTokens);
        
        // Formater le texte analysé
        const analyzedTextHtml = formatAnalyzedText(analyzedTokens);
        
        // Préparer la réponse
        let response = `Voici l'analyse de votre phrase:<br><br>${analyzedTextHtml}<br><br>`;
        
        // Ajouter la structure de la phrase
        response += generateStructureHTML(sentenceStructure);
        
        // Ajouter les catégories grammaticales
        response += `<div class="category-list">`;
        
        // Ordre des catégories
        const categoryOrder = ['pronoun', 'verb', 'noun', 'adjective', 'determiner', 'adverb', 'preposition', 'conjunction', 'negation', 'interjection'];
        
        categoryOrder.forEach(category => {
          const items = categorizedResults[category];
          if (items && items.length > 0) {
            response += generateCategoryHTML(category, items);
          }
        });
        
        response += `</div>`;
        
        return response;
      } catch (error) {
        console.error("Erreur lors de l'analyse:", error);
        return `Une erreur s'est produite lors de l'analyse: ${error.message}`;
      }
    }
    
    // Gestionnaire d'événements
    document.addEventListener('DOMContentLoaded', function() {
      const userInput = document.getElementById('userInput');
      const sendButton = document.getElementById('sendButton');
      
      // Fonction pour envoyer le message
      function sendMessage() {
        const text = userInput.value.trim();
        if (!text) return;
        
        // Afficher le message de l'utilisateur
        addUserMessage(text);
        
        // Effacer l'entrée
        userInput.value = '';
        
        // Afficher l'indicateur de saisie
        addTypingIndicator();
        
        // Analyser la phrase après un court délai pour montrer l'animation
        setTimeout(function() {
          const response = analyzeSentence(text);
          addBotMessage(response);
        }, 1000);
      }
      
      // Écouter le clic sur le bouton d'envoi
      sendButton.addEventListener('click', sendMessage);
      
      // Écouter la touche Entrée dans l'input
      userInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          sendMessage();
        }
      });
      
      // Focus sur l'input au chargement
      userInput.focus();
    });
  </script>
</body>
</html>
