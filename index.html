<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Analyseur Grammatical</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Roboto:wght@300;400;500&display=swap');
    
    :root {
      --primary-color: #5D5CDE;
      --primary-glow: rgba(93, 92, 222, 0.6);
      --secondary-color: #00e5ff;
      --secondary-glow: rgba(0, 229, 255, 0.5);
      --accent-color: #ff00e5;
      --accent-glow: rgba(255, 0, 229, 0.5);
      --success-color: #00ff9d;
      --success-glow: rgba(0, 255, 157, 0.5);
      --warning-color: #ffae00;
      --warning-glow: rgba(255, 174, 0, 0.5);
      --danger-color: #ff3471;
      --danger-glow: rgba(255, 52, 113, 0.5);
      --dark-bg: #121223;
      --card-bg: #1a1a2e;
      --input-bg: #0c0c1d;
      --border-color: #2a2a4a;
      --text-color: #e0e0ff;
      --text-secondary: #9090c0;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Roboto', sans-serif;
      background-color: var(--dark-bg);
      color: var(--text-color);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow-x: hidden;
    }
    
    /* Background animated gradient */
    body::before {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at 20% 30%, rgba(93, 92, 222, 0.1) 0%, transparent 30%),
                  radial-gradient(circle at 80% 20%, rgba(0, 229, 255, 0.07) 0%, transparent 30%),
                  radial-gradient(circle at 30% 70%, rgba(255, 0, 229, 0.07) 0%, transparent 25%);
      z-index: -1;
      pointer-events: none;
    }
    
    .container {
      max-width: 900px;
      width: 100%;
      margin: 0 auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      flex-grow: 1;
    }
    
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 0;
      margin-bottom: 1.5rem;
      border-bottom: 1px solid var(--border-color);
    }
    
    h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.75rem;
      color: var(--primary-color);
      text-shadow: 0 0 10px var(--primary-glow);
      letter-spacing: 1px;
    }
    
    .system-status {
      display: flex;
      align-items: center;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }
    
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: var(--success-color);
      box-shadow: 0 0 10px var(--success-glow);
      margin-right: 0.5rem;
      position: relative;
    }
    
    .status-dot::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background-color: var(--success-color);
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 0.8;
      }
      50% {
        transform: scale(2.5);
        opacity: 0;
      }
      100% {
        transform: scale(1);
        opacity: 0;
      }
    }
    
    /* Chat container */
    .chat-container {
      flex-grow: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      margin-bottom: 1rem;
      padding-right: 0.5rem;
      max-height: calc(100vh - 170px);
    }
    
    /* Scrollbar */
    .chat-container::-webkit-scrollbar {
      width: 6px;
    }
    
    .chat-container::-webkit-scrollbar-track {
      background: var(--input-bg);
      border-radius: 10px;
    }
    
    .chat-container::-webkit-scrollbar-thumb {
      background: var(--primary-color);
      border-radius: 10px;
    }
    
    /* Chat messages */
    .message {
      max-width: 85%;
      margin-bottom: 1rem;
      padding: 0.75rem 1rem;
      border-radius: 1.2rem;
      position: relative;
      animation: fadeIn 0.3s ease-out;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .message.user {
      align-self: flex-end;
      background-color: var(--primary-color);
      box-shadow: 0 0 15px var(--primary-glow);
      border-bottom-right-radius: 0.3rem;
    }
    
    .message.bot {
      align-self: flex-start;
      background-color: var(--card-bg);
      border: 1px solid var(--border-color);
      border-bottom-left-radius: 0.3rem;
    }
    
    .message-content {
      font-size: 0.95rem;
      line-height: 1.4;
    }
    
    .message-time {
      font-size: 0.7rem;
      color: rgba(255, 255, 255, 0.6);
      margin-top: 0.25rem;
      text-align: right;
    }
    
    /* Word tags in bot messages */
    .word-tag {
      display: inline-block;
      padding: 0.1rem 0.4rem;
      border-radius: 0.5rem;
      margin: 0.15rem 0.1rem;
      font-size: 0.9rem;
      font-weight: 500;
      transition: transform 0.2s, box-shadow 0.2s;
      cursor: help;
    }
    
    .word-tag:hover {
      transform: translateY(-2px);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
    }
    
    /* Codes couleur pour chaque cat√©gorie grammaticale */
    .pronoun {
      background-color: #ff517a;
      color: #fff;
    }
    
    .verb {
      background-color: #00a3ff;
      color: #fff;
    }
    
    .determiner {
      background-color: #9c6bff;
      color: #fff;
    }
    
    .noun {
      background-color: #00cf86;
      color: #fff;
    }
    
    .adjective {
      background-color: #ffb347;
      color: #fff;
    }
    
    .adverb {
      background-color: #7c83ff;
      color: #fff;
    }
    
    .preposition {
      background-color: #ff65b2;
      color: #fff;
    }
    
    .conjunction {
      background-color: #c17aff;
      color: #fff;
    }
    
    .negation {
      background-color: #ff5252;
      color: #fff;
    }
    
    .interjection {
      background-color: #ffcc29;
      color: #333;
    }
    
    .subject {
      border: 2px solid #fff;
      padding: 0.15rem 0.45rem;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }
    
    .object {
      border-bottom: 2px dashed #fff;
    }
    
    /* Tooltip */
    .tooltip {
      position: relative;
    }
    
    .tooltip .tooltip-text {
      visibility: hidden;
      position: absolute;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(10, 10, 25, 0.95);
      color: var(--text-color);
      text-align: center;
      border-radius: 6px;
      padding: 0.5rem;
      width: max-content;
      max-width: 200px;
      font-size: 0.75rem;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.3s;
      border: 1px solid var(--border-color);
      pointer-events: none;
    }
    
    .tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }
    
    /* Category list */
    .category-list {
      background-color: var(--card-bg);
      border-radius: 0.6rem;
      padding: 1rem;
      margin-top: 0.5rem;
      border: 1px solid var(--border-color);
    }
    
    .category-header {
      display: flex;
      align-items: center;
      margin-bottom: 0.75rem;
    }
    
    .category-badge {
      padding: 0.3rem 0.6rem;
      border-radius: 0.5rem;
      font-size: 0.75rem;
      font-weight: bold;
      margin-right: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: white;
    }
    
    .pronoun-badge { background-color: #ff517a; }
    .verb-badge { background-color: #00a3ff; }
    .determiner-badge { background-color: #9c6bff; }
    .noun-badge { background-color: #00cf86; }
    .adjective-badge { background-color: #ffb347; }
    .adverb-badge { background-color: #7c83ff; }
    .preposition-badge { background-color: #ff65b2; }
    .conjunction-badge { background-color: #c17aff; }
    .negation-badge { background-color: #ff5252; }
    .interjection-badge { background-color: #ffcc29; color: #333; }
    
    .category-description {
      font-size: 0.8rem;
      color: var(--text-secondary);
    }
    
    .category-content {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }
    
    /* Sentence structure */
    .sentence-structure {
      background-color: var(--card-bg);
      border-radius: 0.6rem;
      padding: 1rem;
      margin-top: 1rem;
      border: 1px solid var(--border-color);
    }
    
    .structure-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 1rem;
      color: var(--primary-color);
      margin-bottom: 0.75rem;
    }
    
    .structure-item {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
    }
    
    .structure-label {
      width: 100px;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }
    
    .structure-value {
      flex-grow: 1;
      font-size: 0.9rem;
    }
    
    /* Input area */
    .input-container {
      position: relative;
      margin-top: auto;
    }
    
    .input-glow {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      border-radius: 16px;
      z-index: -1;
    }
    
    .input-container:focus-within .input-glow {
      box-shadow: 0 0 20px var(--primary-glow);
    }
    
    .chat-input {
      width: 100%;
      padding: 1rem 3.5rem 1rem 1.2rem;
      border-radius: 16px;
      border: 1px solid var(--border-color);
      background-color: var(--input-bg);
      color: var(--text-color);
      font-size: 1rem;
      outline: none;
      transition: all 0.3s;
      box-shadow: 0 0 20px rgba(93, 92, 222, 0.1);
    }
    
    .chat-input:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px var(--primary-glow);
    }
    
    .send-button {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: var(--primary-color);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      transition: all 0.2s;
    }
    
    .send-button:hover {
      background-color: var(--primary-color);
      color: white;
    }
    
    .send-button svg {
      width: 18px;
      height: 18px;
    }
    
    /* Loading animation */
    .typing-indicator {
      display: flex;
      padding: 0.5rem 1rem;
      background-color: var(--card-bg);
      border-radius: 1.2rem;
      border-bottom-left-radius: 0.3rem;
      align-self: flex-start;
      margin-bottom: 1rem;
      width: auto;
    }
    
    .typing-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: var(--text-secondary);
      margin: 0 2px;
      animation: typingBounce 1.4s infinite;
      opacity: 0.6;
    }
    
    .typing-dot:nth-child(1) { animation-delay: 0s; }
    .typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .typing-dot:nth-child(3) { animation-delay: 0.4s; }
    
    @keyframes typingBounce {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-5px); }
    }
    
    /* Futuristic scanner lines effect */
    .scanner-line {
      position: absolute;
      width: 100%;
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--secondary-color), transparent);
      animation: scan 4s infinite;
      opacity: 0.5;
      pointer-events: none;
    }
    
    @keyframes scan {
      0% {
        top: 0;
        opacity: 0;
      }
      5% {
        opacity: 0.8;
      }
      50% {
        top: 100%;
      }
      95% {
        opacity: 0.8;
      }
      100% {
        top: 0;
        opacity: 0;
      }
    }
    
    /* Responsive design */
    @media (max-width: 768px) {
      .container {
        padding: 0.75rem;
      }
      
      h1 {
        font-size: 1.4rem;
      }
      
      .message {
        max-width: 90%;
        padding: 0.6rem 0.75rem;
      }
      
      .chat-input {
        padding: 0.75rem 3rem 0.75rem 1rem;
      }
    }
    
    @media (max-width: 480px) {
      h1 {
        font-size: 1.1rem;
      }
      
      .system-status {
        font-size: 0.7rem;
      }
      
      .message {
        max-width: 95%;
      }
      
      .word-tag {
        font-size: 0.8rem;
        padding: 0.1rem 0.3rem;
      }
    }
  </style>
</head>
<body>
  <div class="scanner-line"></div>
  
  <div class="container">
    <header>
      <h1>DYNAMIC ANALYZER</h1>
      <div class="system-status">
        <div class="status-dot"></div>
        <span>Syst√®me op√©rationnel</span>
      </div>
    </header>
    
    <div class="chat-container" id="chatContainer">
      <div class="message bot">
        <div class="message-content">
          Bonjour, je suis votre <span class="word-tag adjective tooltip">intelligent<span class="tooltip-text">Adjectif qualificatif</span></span> analyseur grammatical. √âcrivez une phrase en fran√ßais, et je l'analyserai pour vous.
        </div>
        <div class="message-time">Aujourd'hui</div>
      </div>
    </div>
    
    <div class="input-container">
      <div class="input-glow"></div>
      <input type="text" class="chat-input" id="userInput" placeholder="Tapez votre phrase ici..." autocomplete="off">
      <button class="send-button" id="sendButton">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
        </svg>
      </button>
    </div>
  </div>

  <script>
    // Descriptions des cat√©gories grammaticales
    const categoryDescriptions = {
      pronoun: "Les pronoms remplacent g√©n√©ralement un nom ou un groupe nominal.",
      verb: "Les verbes expriment des actions, des √©tats ou des processus.",
      noun: "Les noms d√©signent des personnes, des lieux, des objets ou des concepts.",
      adjective: "Les adjectifs qualifient ou d√©terminent les noms.",
      determiner: "Les d√©terminants pr√©cisent l'identit√© ou la quantit√© du nom qu'ils accompagnent.",
      adverb: "Les adverbes modifient un verbe, un adjectif ou un autre adverbe.",
      preposition: "Les pr√©positions relient des mots ou groupes de mots entre eux.",
      conjunction: "Les conjonctions relient des mots, des propositions ou des phrases.",
      negation: "Les n√©gations sont utilis√©es pour nier une affirmation.",
      interjection: "Les interjections expriment une √©motion ou une r√©action."
    };
    
    // Noms des cat√©gories en fran√ßais
    const categoryNames = {
      pronoun: "Pronom",
      verb: "Verbe",
      noun: "Nom",
      adjective: "Adjectif",
      determiner: "D√©terminant",
      adverb: "Adverbe",
      preposition: "Pr√©position",
      conjunction: "Conjonction",
      negation: "N√©gation",
      interjection: "Interjection"
    };
    
    // Base de donn√©es linguistique fran√ßaise (lexique et r√®gles)
    const frenchLexicon = {
      // Articles d√©finis
      definiteArticles: {
        singular: ["le", "la", "l'"],
        plural: ["les"]
      },
      
      // Articles ind√©finis
      indefiniteArticles: {
        singular: ["un", "une"],
        plural: ["des"]
      },
      
      // Articles partitifs
      partitiveArticles: ["du", "de la", "de l'", "des"],
      
      // D√©terminants possessifs
      possessiveDeterminers: [
        "mon", "ma", "mes", 
        "ton", "ta", "tes", 
        "son", "sa", "ses", 
        "notre", "nos", 
        "votre", "vos", 
        "leur", "leurs"
      ],
      
      // D√©terminants d√©monstratifs
      demonstrativeDeterminers: ["ce", "cet", "cette", "ces"],
      
      // D√©terminants ind√©finis
      indefiniteDeterminers: [
        "chaque", "quelque", "quelques", "tout", "toute", "tous", "toutes",
        "certain", "certaine", "certains", "certaines", "plusieurs", 
        "aucun", "aucune", "nul", "nulle", "autre", "autres",
        "m√™me", "m√™mes", "tel", "telle", "tels", "telles"
      ],
      
      // Pronoms personnels
      personalPronouns: {
        subject: ["je", "j'", "tu", "il", "elle", "on", "nous", "vous", "ils", "elles"],
        object: ["me", "m'", "te", "t'", "le", "l'", "la", "lui", "se", "s'", "nous", "vous", "les", "leur"],
        tonic: ["moi", "toi", "lui", "elle", "soi", "nous", "vous", "eux", "elles"],
        reflexive: ["me", "m'", "te", "t'", "se", "s'", "nous", "vous"],
        adverbial: ["y", "en"]
      },
      
      // Pronoms d√©monstratifs
      demonstrativePronouns: ["ce", "c'", "√ßa", "ceci", "cela", "celui", "celle", "ceux", "celles", "celui-ci", "celle-ci", "ceux-ci", "celles-ci"],
      
      // Pronoms relatifs
      relativePronouns: ["qui", "que", "qu'", "quoi", "dont", "o√π", "lequel", "laquelle", "lesquels", "lesquelles"],
      
      // Pronoms interrogatifs
      interrogativePronouns: ["qui", "que", "quoi", "lequel", "laquelle", "lesquels", "lesquelles"],
      
      // Pronoms ind√©finis
      indefinitePronouns: ["on", "tout", "tous", "toute", "toutes", "aucun", "aucune", "nul", "nulle", "personne", "rien", "chacun", "chacune", "quelqu'un", "quelques-uns", "quelques-unes", "plusieurs", "certains", "certaines", "autre", "autres"],
      
      // Pr√©positions
      prepositions: [
        "√†", "au", "aux", "apr√®s", "avant", "avec", "chez", "contre", "dans", 
        "de", "des", "du", "depuis", "derri√®re", "d√®s", "devant", "durant", 
        "en", "entre", "envers", "hormis", "hors", "jusque", "malgr√©", "outre", 
        "par", "parmi", "pendant", "pour", "pr√®s", "sans", "sauf", "selon", 
        "sous", "suivant", "sur", "vers", "via"
      ],
      
      // Conjonctions de coordination
      coordinatingConjunctions: ["et", "mais", "ou", "donc", "or", "ni", "car"],
      
      // Conjonctions de subordination
      subordinatingConjunctions: [
        "que", "qu'", "quand", "comme", "si", "lorsque", "puisque", "quoique", 
        "parce", "bien que", "afin que", "pour que", "tandis que", "alors que"
      ],
      
      // Adverbes courants
      commonAdverbs: [
        "ainsi", "alors", "assez", "aujourd'hui", "aussi", "autant", "autrefois", 
        "beaucoup", "bien", "bient√¥t", "certes", "combien", "comment", "davantage", 
        "debout", "dedans", "dehors", "d√©j√†", "demain", "encore", "enfin", "ensemble", 
        "ensuite", "environ", "fort", "hier", "ici", "jamais", "l√†", "loin", 
        "longtemps", "lors", "maintenant", "mal", "mieux", "moins", "parfois", 
        "partout", "peu", "plus", "plusieurs", "plut√¥t", "presque", "puis", 
        "quasiment", "quelquefois", "seulement", "si", "souvent", "tant", 
        "tant√¥t", "tard", "tellement", "t√¥t", "toujours", "toutefois", "tr√®s", 
        "trop", "vite", "volontiers", "vraiment"
      ],
      
      // Mots de n√©gation
      negationWords: ["ne", "n'", "pas", "plus", "jamais", "gu√®re", "point", "nullement", "aucunement"],
      
      // Interjections
      interjections: ["ah", "oh", "eh", "h√©", "a√Øe", "ouf", "hein", "bah", "pff", "zut", "youpi", "bravo", "hourra"],
      
      // Verbes auxiliaires
      auxiliaryVerbs: {
        avoir: {
          infinitive: "avoir",
          presentParticiple: "ayant",
          pastParticiple: ["eu", "eue", "eus", "eues"],
          present: {
            singular: ["ai", "as", "a"],
            plural: ["avons", "avez", "ont"]
          },
          imperfect: {
            singular: ["avais", "avais", "avait"],
            plural: ["avions", "aviez", "avaient"]
          },
          future: {
            singular: ["aurai", "auras", "aura"],
            plural: ["aurons", "aurez", "auront"]
          }
        },
        √™tre: {
          infinitive: "√™tre",
          presentParticiple: "√©tant",
          pastParticiple: ["√©t√©"],
          present: {
            singular: ["suis", "es", "est"],
            plural: ["sommes", "√™tes", "sont"]
          },
          imperfect: {
            singular: ["√©tais", "√©tais", "√©tait"],
            plural: ["√©tions", "√©tiez", "√©taient"]
          },
          future: {
            singular: ["serai", "seras", "sera"],
            plural: ["serons", "serez", "seront"]
          }
        }
      },
      
      // Dictionnaire de verbes (exemples)
      verbs: {
        // Premier groupe (-er)
        "aimer": {
          infinitive: "aimer",
          group: 1,
          present: {
            singular: ["aime", "aimes", "aime"],
            plural: ["aimons", "aimez", "aiment"]
          }
        },
        "parler": {
          infinitive: "parler",
          group: 1,
          present: {
            singular: ["parle", "parles", "parle"],
            plural: ["parlons", "parlez", "parlent"]
          }
        },
        "donner": {
          infinitive: "donner",
          group: 1,
          present: {
            singular: ["donne", "donnes", "donne"],
            plural: ["donnons", "donnez", "donnent"]
          }
        },
        "trouver": {
          infinitive: "trouver",
          group: 1,
          present: {
            singular: ["trouve", "trouves", "trouve"],
            plural: ["trouvons", "trouvez", "trouvent"]
          }
        },
        "regarder": {
          infinitive: "regarder",
          group: 1,
          present: {
            singular: ["regarde", "regardes", "regarde"],
            plural: ["regardons", "regardez", "regardent"]
          }
        },
        "manger": {
          infinitive: "manger",
          group: 1,
          present: {
            singular: ["mange", "manges", "mange"],
            plural: ["mangeons", "mangez", "mangent"]
          }
        },
        
        // Deuxi√®me groupe (-ir)
        "finir": {
          infinitive: "finir",
          group: 2,
          present: {
            singular: ["finis", "finis", "finit"],
            plural: ["finissons", "finissez", "finissent"]
          }
        },
        "choisir": {
          infinitive: "choisir",
          group: 2,
          present: {
            singular: ["choisis", "choisis", "choisit"],
            plural: ["choisissons", "choisissez", "choisissent"]
          }
        },
        
        // Troisi√®me groupe (irr√©guliers)
        "faire": {
          infinitive: "faire",
          group: 3,
          present: {
            singular: ["fais", "fais", "fait"],
            plural: ["faisons", "faites", "font"]
          }
        },
        "dire": {
          infinitive: "dire",
          group: 3,
          present: {
            singular: ["dis", "dis", "dit"],
            plural: ["disons", "dites", "disent"]
          }
        },
        "venir": {
          infinitive: "venir",
          group: 3,
          present: {
            singular: ["viens", "viens", "vient"],
            plural: ["venons", "venez", "viennent"]
          }
        },
        "voir": {
          infinitive: "voir",
          group: 3,
          present: {
            singular: ["vois", "vois", "voit"],
            plural: ["voyons", "voyez", "voient"]
          }
        },
        "prendre": {
          infinitive: "prendre",
          group: 3,
          present: {
            singular: ["prends", "prends", "prend"],
            plural: ["prenons", "prenez", "prennent"]
          }
        },
        "aller": {
          infinitive: "aller",
          group: 3,
          present: {
            singular: ["vais", "vas", "va"],
            plural: ["allons", "allez", "vont"]
          }
        },
        
        // Verbes pronominaux
        "s'amuser": {
          infinitive: "s'amuser",
          group: 1,
          pronominal: true,
          present: {
            singular: ["m'amuse", "t'amuses", "s'amuse"],
            plural: ["nous amusons", "vous amusez", "s'amusent"]
          },
          // Formes d√©taill√©es pour l'analyse
          presentComponents: {
            singular: [
              { pronoun: "me", verb: "amuse" },
              { pronoun: "te", verb: "amuses" },
              { pronoun: "se", verb: "amuse" }
            ],
            plural: [
              { pronoun: "nous", verb: "amusons" },
              { pronoun: "vous", verb: "amusez" },
              { pronoun: "se", verb: "amusent" }
            ]
          }
        },
        "se lever": {
          infinitive: "se lever",
          group: 1,
          pronominal: true,
          present: {
            singular: ["me l√®ve", "te l√®ves", "se l√®ve"],
            plural: ["nous levons", "vous levez", "se l√®vent"]
          },
          presentComponents: {
            singular: [
              { pronoun: "me", verb: "l√®ve" },
              { pronoun: "te", verb: "l√®ves" },
              { pronoun: "se", verb: "l√®ve" }
            ],
            plural: [
              { pronoun: "nous", verb: "levons" },
              { pronoun: "vous", verb: "levez" },
              { pronoun: "se", verb: "l√®vent" }
            ]
          }
        }
      },
      
      // Terminaisons verbales par groupe
      verbEndings: {
        // Pr√©sent de l'indicatif
        indicativePresent: {
          firstGroup: {  // -er
            singular: ["e", "es", "e"],
            plural: ["ons", "ez", "ent"]
          },
          secondGroup: {  // -ir
            singular: ["is", "is", "it"],
            plural: ["issons", "issez", "issent"]
          },
          thirdGroup: {  // diverses, g√©n√©rales
            singular: ["s", "s", "t/d"],
            plural: ["ons", "ez", "ent"]
          }
        }
      },
      
      // Adjectifs communs
      commonAdjectives: [
        // Adjectifs de base
        "petit", "petite", "petits", "petites",
        "grand", "grande", "grands", "grandes",
        "beau", "belle", "beaux", "belles",
        "nouveau", "nouvelle", "nouveaux", "nouvelles",
        "vieux", "vieille", "vieux", "vieilles",
        "bon", "bonne", "bons", "bonnes",
        "mauvais", "mauvaise", "mauvais", "mauvaises",
        "joli", "jolie", "jolis", "jolies",
        "gros", "grosse", "gros", "grosses",
        
        // Adjectifs de couleur
        "blanc", "blanche", "blancs", "blanches",
        "noir", "noire", "noirs", "noires",
        "bleu", "bleue", "bleus", "bleues",
        "rouge", "rouges",
        "vert", "verte", "verts", "vertes",
        "jaune", "jaunes",
        "orange",
        "rose", "roses",
        "violet", "violette", "violets", "violettes",
        "gris", "grise", "gris", "grises",
        "marron",
        "brun", "brune", "bruns", "brunes"
      ],
      
      // Noms communs fr√©quents (liste partielle)
      commonNouns: [
        // Personnes
        "homme", "femme", "enfant", "gar√ßon", "fille", "b√©b√©", "adulte", 
        "ami", "amie", "amis", "amies", "famille", "m√®re", "p√®re", "parent", "parents",
        "fr√®re", "s≈ìur", "fils", "fille", "oncle", "tante", "cousin", "cousine",
        "grand-p√®re", "grand-m√®re", "grands-parents", "voisin", "voisine",
        
        // Objets
        "chose", "objet", "livre", "table", "chaise", "porte", "fen√™tre", "lit",
        "stylo", "crayon", "papier", "journal", "magazine", "t√©l√©phone", "ordinateur",
        "voiture", "v√©lo", "train", "avion", "bateau", "bus", "m√©tro",
        
        // Aliments (ajout√©s pour l'exemple "Une pomme est mang√©e par elle")
        "pomme", "pommes", "fruit", "fruits", "l√©gume", "l√©gumes", "pain", "eau",
        
        // Lieux
        "maison", "appartement", "bureau", "√©cole", "universit√©", "entreprise",
        "magasin", "restaurant", "h√¥tel", "h√¥pital", "ville", "pays", "rue", "route",
        "place", "parc", "jardin", "for√™t", "montagne", "plage", "mer", "oc√©an", "rivi√®re",
        
        // Concepts
        "temps", "heure", "minute", "seconde", "jour", "nuit", "matin", "soir",
        "semaine", "mois", "ann√©e", "si√®cle", "moment", "vie", "mort", "id√©e",
        "pens√©e", "sentiment", "√©motion", "amour", "haine", "joie", "tristesse",
        "peur", "courage", "espoir", "r√™ve", "v√©rit√©", "mensonge", "probl√®me", "solution",
        
        // Ajout sp√©cifique pour les tests
        "enfants"
      ],
      
      // Indicateurs de voix passive
      passiveVoiceIndicators: [
        "est", "sont", "fut", "furent", 
        "√©tait", "√©taient", "sera", "seront",
        "a √©t√©", "ont √©t√©", "avait √©t√©", "avaient √©t√©"
      ],
      
      // Pr√©positions introduisant un compl√©ment d'agent
      agentPrepositions: ["par", "de"]
    };
    
    // Motifs grammaticaux (pour l'analyse en contexte)
    const grammarPatterns = {
      // Structure: d√©terminant + nom
      determinerNoun: {
        match: ["determiner", "noun"],
        example: "le chat"
      },
      
      // Structure: d√©terminant + adjectif + nom
      determinerAdjectiveNoun: {
        match: ["determiner", "adjective", "noun"],
        example: "la grande maison"
      },
      
      // Structure: d√©terminant + nom + adjectif
      determinerNounAdjective: {
        match: ["determiner", "noun", "adjective"],
        example: "le chat noir"
      },
      
      // Structure: pronom personnel sujet + verbe
      personalPronounVerb: {
        match: ["personal_pronoun_subject", "verb"],
        example: "je mange"
      },
      
      // Structure: verbe pronominal (pronom r√©fl√©chi + verbe)
      reflexivePronounVerb: {
        match: ["reflexive_pronoun", "verb"],
        example: "se laver"
      },
      
      // Structure: sujet + verbe
      subjectVerb: {
        match: ["noun|personal_pronoun_subject", "verb"],
        example: "l'enfant joue"
      },
      
      // Structure: verbe + compl√©ment d'objet direct
      verbDirectObject: {
        match: ["verb", "determiner", "noun"],
        example: "mange une pomme"
      },
      
      // Structure: voix passive
      passiveVoice: {
        match: ["determiner", "noun", "auxiliary", "pastParticiple", "preposition", "noun|pronoun"],
        example: "la pomme est mang√©e par lui"
      },
      
      // Structure simplifi√©e pour la voix passive
      simplePassiveVoice: {
        match: ["noun|pronoun", "auxiliary", "pastParticiple"],
        example: "le livre est lu"
      }
    };
    
    // Fonction pour tokeniser le texte
    function tokenizeText(text) {
      const tokens = [];
      
      // Pr√©traiter le texte pour g√©rer les √©lisions (mettre des espaces autour des apostrophes)
      let processedText = text.replace(/([a-zA-Z√Ä-√ø])'([a-zA-Z√Ä-√ø])/g, "$1' $2");
      
      // Pr√©traiter pour g√©rer les expressions compos√©es (comme "parce que")
      const compoundExpressions = [
        "parce que", "bien que", "afin que", "pour que", "tandis que", "alors que",
        "il y a", "est-ce que", "c'est-√†-dire", "d'apr√®s", "tout √† fait", 
        "au-dessus", "au-dessous", "au lieu de", "en train de"
      ];
      
      // D√©couper le texte en tokens (mots et ponctuations)
      const rawTokens = processedText.match(/[a-zA-Z√Ä-√ø'']+|[.,!?;:()]/g) || [];
      
      // Traiter chaque token
      for (let i = 0; i < rawTokens.length; i++) {
        const token = rawTokens[i];
        
        // Ignorer les tokens vides
        if (!token.trim()) continue;
        
        // Traiter les signes de ponctuation
        if (/^[.,!?;:()]$/.test(token)) {
          tokens.push({ 
            original: token, 
            normalized: token, 
            type: "punctuation",
            position: tokens.length
          });
          continue;
        }
        
        // Traiter les √©lisions (j', l', etc.)
        if (token.endsWith("'")) {
          const elisionBase = token.slice(0, -1).toLowerCase();
          
          // Mapper les √©lisions courantes √† leur forme compl√®te
          let normalizedToken = elisionBase;
          if (elisionBase === "j") normalizedToken = "je";
          else if (elisionBase === "c") normalizedToken = "ce";
          else if (elisionBase === "s") normalizedToken = "se";
          else if (elisionBase === "d") normalizedToken = "de";
          else if (elisionBase === "l") normalizedToken = "le";
          else if (elisionBase === "m") normalizedToken = "me";
          else if (elisionBase === "n") normalizedToken = "ne";
          else if (elisionBase === "t") normalizedToken = "te";
          else if (elisionBase === "qu") normalizedToken = "que";
          
          tokens.push({
            original: token,
            normalized: normalizedToken,
            isElided: true,
            position: tokens.length
          });
          
          continue;
        }
        
        // D√©tecter si ce token fait partie d'une expression compos√©e
        let isPartOfCompound = false;
        for (const expr of compoundExpressions) {
          const exprParts = expr.split(" ");
          if (i + exprParts.length <= rawTokens.length) {
            const potentialMatch = [];
            for (let j = 0; j < exprParts.length; j++) {
              potentialMatch.push(rawTokens[i + j].toLowerCase());
            }
            
            if (potentialMatch.join(" ") === expr) {
              tokens.push({
                original: potentialMatch.map((t, idx) => rawTokens[i + idx]).join(" "),
                normalized: expr,
                isCompound: true,
                componentCount: exprParts.length,
                position: tokens.length
              });
              
              // Avancer l'index pour sauter les tokens qui font partie de cette expression
              i += exprParts.length - 1;
              isPartOfCompound = true;
              break;
            }
          }
        }
        
        if (isPartOfCompound) continue;
        
        // Token standard
        tokens.push({
          original: token,
          normalized: token.toLowerCase(),
          position: tokens.length
        });
      }
      
      return tokens;
    }
    
    // Fonction principale d'analyse grammaticale
    function analyzeGrammar(tokens) {
      // Premi√®re √©tape: √©tiquetage morphologique initial (POS tagging)
      const taggedTokens = tokens.map((token, index) => {
        if (token.type === "punctuation") return token;
        
        // Analyse morphologique de base
        return {
          ...token,
          ...analyzeTokenType(token, tokens, index)
        };
      });
      
      // Deuxi√®me √©tape: analyse syntaxique et r√©solution des ambigu√Øt√©s
      const analyzedTokens = syntacticAnalysis(taggedTokens);
      
      // Troisi√®me √©tape: d√©tection des structures sp√©ciales (verbes pronominaux, voix passive, etc.)
      const structuredTokens = detectSpecialStructures(analyzedTokens);
      
      // Quatri√®me √©tape: identification des sujets, verbes et compl√©ments
      return identifySentenceComponents(structuredTokens);
    }
    
    // Analyse morphologique (premi√®re √©tape)
    function analyzeTokenType(token, tokens, position) {
      const word = token.normalized;
      
      // 1. D√©tection des d√©terminants
      const determinerCheck = isDeterminer(word);
      if (determinerCheck) {
        return determinerCheck;
      }
      
      // 2. D√©tection des pronoms
      const pronounCheck = isPronoun(word);
      if (pronounCheck) {
        return pronounCheck;
      }
      
      // 3. D√©tection des verbes
      const verbCheck = isVerb(word, tokens, position);
      if (verbCheck) {
        return verbCheck;
      }
      
      // 4. D√©tection des pr√©positions
      if (frenchLexicon.prepositions.includes(word)) {
        return { type: "preposition" };
      }
      
      // 5. D√©tection des conjonctions
      if (frenchLexicon.coordinatingConjunctions.includes(word)) {
        return { type: "conjunction", subtype: "coordination" };
      }
      
      for (const subConj of frenchLexicon.subordinatingConjunctions) {
        if (word === subConj || word.startsWith(subConj + " ")) {
          return { type: "conjunction", subtype: "subordination" };
        }
      }
      
      // 6. D√©tection des adverbes
      if (frenchLexicon.commonAdverbs.includes(word)) {
        return { type: "adverb" };
      }
      
      // 7. D√©tection des mots de n√©gation
      if (frenchLexicon.negationWords.includes(word)) {
        return { type: "negation" };
      }
      
      // 8. D√©tection des interjections
      if (frenchLexicon.interjections.includes(word)) {
        return { type: "interjection" };
      }
      
      // 9. D√©tection des noms communs connus
      if (frenchLexicon.commonNouns.includes(word)) {
        return { type: "noun", subtype: "common" };
      }
      
      // 10. D√©tection des adjectifs courants
      if (frenchLexicon.commonAdjectives.includes(word)) {
        return { type: "adjective", subtype: "qualificatif" };
      }
      
      // 11. Analyse contextuelle (utilisation du contexte pour d√©terminer la nature probable)
      const contextualCheck = analyzeByContext(word, tokens, position);
      if (contextualCheck) {
        return contextualCheck;
      }
      
      // 12. Analyse par terminaison (r√®gles morphologiques)
      const suffixCheck = analyzeByEnding(word);
      if (suffixCheck) {
        return suffixCheck;
      }
      
      // Par d√©faut, probablement un nom (la cat√©gorie la plus commune pour les mots inconnus)
      return { type: "noun", subtype: "ind√©termin√©", confidence: "low" };
    }
    
    // V√©rifier si le mot est un d√©terminant
    function isDeterminer(word) {
      // Articles d√©finis
      if (frenchLexicon.definiteArticles.singular.includes(word) || 
          frenchLexicon.definiteArticles.plural.includes(word)) {
        return { type: "determiner", subtype: "article d√©fini" };
      }
      
      // Articles ind√©finis
      if (frenchLexicon.indefiniteArticles.singular.includes(word) || 
          frenchLexicon.indefiniteArticles.plural.includes(word)) {
        return { type: "determiner", subtype: "article ind√©fini" };
      }
      
      // Articles partitifs
      if (frenchLexicon.partitiveArticles.includes(word)) {
        return { type: "determiner", subtype: "article partitif" };
      }
      
      // D√©terminants possessifs
      if (frenchLexicon.possessiveDeterminers.includes(word)) {
        return { type: "determiner", subtype: "possessif" };
      }
      
      // D√©terminants d√©monstratifs
      if (frenchLexicon.demonstrativeDeterminers.includes(word)) {
        return { type: "determiner", subtype: "d√©monstratif" };
      }
      
      // D√©terminants ind√©finis
      if (frenchLexicon.indefiniteDeterminers.includes(word)) {
        return { type: "determiner", subtype: "ind√©fini" };
      }
      
      return null;
    }
    
    // V√©rifier si le mot est un pronom
    function isPronoun(word) {
      // Pronoms personnels sujets
      if (frenchLexicon.personalPronouns.subject.includes(word)) {
        return { type: "pronoun", subtype: "personnel sujet" };
      }
      
      // Pronoms personnels compl√©ments
      if (frenchLexicon.personalPronouns.object.includes(word)) {
        return { type: "pronoun", subtype: "personnel compl√©ment" };
      }
      
      // Pronoms personnels toniques
      if (frenchLexicon.personalPronouns.tonic.includes(word)) {
        return { type: "pronoun", subtype: "personnel tonique" };
      }
      
      // Pronoms r√©fl√©chis
      if (frenchLexicon.personalPronouns.reflexive.includes(word)) {
        return { type: "pronoun", subtype: "r√©fl√©chi" };
      }
      
      // Pronoms adverbiaux
      if (frenchLexicon.personalPronouns.adverbial.includes(word)) {
        return { type: "pronoun", subtype: "adverbial" };
      }
      
      // Pronoms d√©monstratifs
      if (frenchLexicon.demonstrativePronouns.includes(word)) {
        return { type: "pronoun", subtype: "d√©monstratif" };
      }
      
      // Pronoms relatifs
      if (frenchLexicon.relativePronouns.includes(word)) {
        return { type: "pronoun", subtype: "relatif" };
      }
      
      // Pronoms interrogatifs
      if (frenchLexicon.interrogativePronouns.includes(word)) {
        return { type: "pronoun", subtype: "interrogatif" };
      }
      
      // Pronoms ind√©finis
      if (frenchLexicon.indefinitePronouns.includes(word)) {
        return { type: "pronoun", subtype: "ind√©fini" };
      }
      
      return null;
    }
    
    // V√©rifier si le mot est un verbe (en utilisant le contexte)
    function isVerb(word, tokens, position) {
      // V√©rifier dans le dictionnaire des verbes
      for (const [infinitive, verbData] of Object.entries(frenchLexicon.verbs)) {
        // V√©rifier l'infinitif
        if (word === verbData.infinitive) {
          return { 
            type: "verb", 
            subtype: "infinitif", 
            infinitive: infinitive,
            group: verbData.group
          };
        }
        
        // V√©rifier les formes conjugu√©es
        if (verbData.present) {
          // Singulier
          for (let i = 0; i < verbData.present.singular.length; i++) {
            if (word === verbData.present.singular[i]) {
              return { 
                type: "verb", 
                subtype: "indicatif pr√©sent", 
                person: i + 1, 
                number: "singular",
                infinitive: infinitive,
                group: verbData.group
              };
            }
          }
          
          // Pluriel
          for (let i = 0; i < verbData.present.plural.length; i++) {
            if (word === verbData.present.plural[i]) {
              return { 
                type: "verb", 
                subtype: "indicatif pr√©sent", 
                person: i + 1, 
                number: "plural",
                infinitive: infinitive,
                group: verbData.group
              };
            }
          }
        }
      }
      
      // V√©rifier les verbes auxiliaires
      for (const [auxName, auxData] of Object.entries(frenchLexicon.auxiliaryVerbs)) {
        // V√©rifier l'infinitif
        if (word === auxData.infinitive) {
          return { 
            type: "verb", 
            subtype: "auxiliaire", 
            infinitive: auxData.infinitive
          };
        }
        
        // V√©rifier participe pr√©sent
        if (word === auxData.presentParticiple) {
          return { 
            type: "verb", 
            subtype: "participe pr√©sent", 
            infinitive: auxData.infinitive
          };
        }
        
        // V√©rifier participe pass√©
        if (auxData.pastParticiple.includes(word)) {
          return { 
            type: "verb", 
            subtype: "participe pass√©", 
            infinitive: auxData.infinitive
          };
        }
        
        // Pr√©sent
        // Singulier
        for (let i = 0; i < auxData.present.singular.length; i++) {
          if (word === auxData.present.singular[i]) {
            return { 
              type: "verb", 
              subtype: "auxiliaire indicatif pr√©sent", 
              person: i + 1, 
              number: "singular",
              infinitive: auxData.infinitive,
              isAuxiliary: true
            };
          }
        }
        
        // Pluriel
        for (let i = 0; i < auxData.present.plural.length; i++) {
          if (word === auxData.present.plural[i]) {
            return { 
              type: "verb", 
              subtype: "auxiliaire indicatif pr√©sent", 
              person: i + 1, 
              number: "plural",
              infinitive: auxData.infinitive,
              isAuxiliary: true
            };
          }
        }
      }
      
      // V√©rifier les terminaisons verbales typiques
      const verbDeduce = deduceVerbForm(word);
      if (verbDeduce.isVerb) {
        return {
          type: "verb",
          subtype: verbDeduce.tense,
          person: verbDeduce.person,
          number: verbDeduce.number,
          infinitive: verbDeduce.infinitive,
          group: verbDeduce.group,
          confidence: "medium"
        };
      }
      
      // V√©rifier le contexte pour les verbes pronominaux
      // exemple: "s'amusent" peut √™tre s√©par√© en "s'" (pronom r√©fl√©chi) et "amusent" (verbe)
      if (position > 0) {
        const prevToken = tokens[position - 1];
        if (prevToken && prevToken.normalized === "s'" || prevToken.normalized === "se") {
          // V√©rifier si ce mot pourrait √™tre la partie verbale d'un verbe pronominal
          const verbStem = extractVerbStem(word);
          
          // V√©rifier avec les terminaisons de l'indicatif pr√©sent, 3√®me personne du pluriel
          if (word.endsWith("ent") && word.length > 3) {
            return {
              type: "verb",
              subtype: "indicatif pr√©sent (pronominal)",
              person: 3,
              number: "plural",
              infinitive: verbStem + "er", // Hypoth√®se du 1er groupe
              group: 1,
              reflexive: true,
              confidence: "high"
            };
          }
        }
      }
      
      // D√©tecter les participes pass√©s
      if ((word.endsWith("√©") || word.endsWith("i") || word.endsWith("u") || 
           word.endsWith("is") || word.endsWith("√©e") || word.endsWith("√©s") || 
           word.endsWith("√©es") || word.endsWith("ts") || word.endsWith("us") || 
           word.endsWith("ues")) && word.length > 2) {
        
        // Si le mot pr√©c√©dent est une forme d'√™tre ou avoir, c'est probablement un participe pass√©
        if (position > 0) {
          const prevToken = tokens[position - 1];
          if (prevToken && isAuxiliaryVerb(prevToken.normalized)) {
            return {
              type: "verb",
              subtype: "participe pass√©",
              infinitive: deduceInfinitiveFromParticiple(word),
              confidence: "high",
              isPastParticiple: true
            };
          }
        }
        
        // Si pas pr√©c√©d√© d'un auxiliaire mais a une forme de participe pass√©
        return {
          type: "verb",
          subtype: "participe pass√©",
          infinitive: deduceInfinitiveFromParticiple(word),
          confidence: "medium",
          isPastParticiple: true
        };
      }
      
      return null;
    }
    
    // V√©rifier si un mot est un verbe auxiliaire
    function isAuxiliaryVerb(word) {
      // Formes d'√™tre
      const etrePresent = ["suis", "es", "est", "sommes", "√™tes", "sont"];
      const etreImperfect = ["√©tais", "√©tait", "√©tions", "√©tiez", "√©taient"];
      
      // Formes d'avoir
      const avoirPresent = ["ai", "as", "a", "avons", "avez", "ont"];
      const avoirImperfect = ["avais", "avait", "avions", "aviez", "avaient"];
      
      return etrePresent.includes(word) || etreImperfect.includes(word) || 
             avoirPresent.includes(word) || avoirImperfect.includes(word);
    }
    
    // D√©duire l'infinitif √† partir d'un participe pass√©
    function deduceInfinitiveFromParticiple(participle) {
      // R√®gles de base pour d√©duire l'infinitif √† partir d'un participe pass√©
      const baseForm = participle.replace(/e?s$|e$|es$|√©e?s?$/, "");
      
      if (participle.endsWith("√©") || participle.endsWith("√©e") || 
          participle.endsWith("√©s") || participle.endsWith("√©es")) {
        return baseForm + "er"; // Premier groupe
      } else if (participle.endsWith("i") || participle.endsWith("ie") || 
                 participle.endsWith("is") || participle.endsWith("ies")) {
        return baseForm + "ir"; // Deuxi√®me groupe ou troisi√®me groupe
      } else if (participle.endsWith("u") || participle.endsWith("ue") || 
                 participle.endsWith("us") || participle.endsWith("ues")) {
        // Tenter de deviner pour les verbes du 3e groupe
        if (baseForm.endsWith("v")) return baseForm + "oir"; // ex: vu -> voir
        if (baseForm.endsWith("d")) return baseForm + "re"; // ex: rendu -> rendre
        return baseForm + "re"; // Hypoth√®se pour troisi√®me groupe
      }
      
      return participle; // Par d√©faut
    }
    
    // Analyse par contexte
    function analyzeByContext(word, tokens, position) {
      // 1. Si pr√©c√©d√© d'un d√©terminant, probablement un nom ou un adjectif
      if (position > 0) {
        const prevToken = tokens[position - 1];
        if (prevToken && isDeterminer(prevToken.normalized)) {
          // Si suivi d'un mot qui est clairement un nom, probablement un adjectif
          if (position < tokens.length - 1) {
            const nextToken = tokens[position + 1];
            if (nextToken && frenchLexicon.commonNouns.includes(nextToken.normalized)) {
              return { type: "adjective", subtype: "qualificatif", position: "avant le nom", confidence: "medium" };
            }
          }
          
          // Sinon, probablement un nom
          return { type: "noun", subtype: "commun", confidence: "medium" };
        }
      }
      
      // 2. Si pr√©c√©d√© d'un pronom personnel sujet, probablement un verbe
      if (position > 0) {
        const prevToken = tokens[position - 1];
        if (prevToken && frenchLexicon.personalPronouns.subject.includes(prevToken.normalized)) {
          return { type: "verb", subtype: "indicatif pr√©sent", confidence: "medium" };
        }
      }
      
      // 3. Si pr√©c√©d√© d'une pr√©position, probablement un nom
      if (position > 0) {
        const prevToken = tokens[position - 1];
        if (prevToken && frenchLexicon.prepositions.includes(prevToken.normalized)) {
          return { type: "noun", subtype: "commun", confidence: "medium" };
        }
      }
      
      // 4. D√©tection des verbes pronominaux ("s'amusent", etc.)
      if (position > 0) {
        const prevToken = tokens[position - 1];
        // Si pr√©c√©d√© de "s'" ou "se", probablement partie d'un verbe pronominal
        if (prevToken && (prevToken.normalized === "se" || prevToken.normalized === "s'")) {
          // V√©rifier les terminaisons verbales
          if (word.endsWith("e") || word.endsWith("es") || word.endsWith("ons") || 
              word.endsWith("ez") || word.endsWith("ent")) {
            return { 
              type: "verb", 
              subtype: "indicatif pr√©sent (pronominal)", 
              confidence: "high"
            };
          }
        }
      }
      
      // 5. D√©tecter les structures de voix passive
      if (position > 0 && position < tokens.length - 1) {
        const prevToken = tokens[position - 1];
        const nextToken = tokens[position + 1];
        
        // Si le mot est "est" ou une autre forme d'√™tre et est suivi d'un possible participe pass√©
        if (frenchLexicon.auxiliaryVerbs.√™tre.present.singular.includes(word) ||
            frenchLexicon.auxiliaryVerbs.√™tre.present.plural.includes(word)) {
          
          // V√©rifier si le token suivant est potentiellement un participe pass√©
          if (nextToken && 
              (nextToken.normalized.endsWith("√©") || 
               nextToken.normalized.endsWith("ie") || 
               nextToken.normalized.endsWith("is") || 
               nextToken.normalized.endsWith("u") || 
               nextToken.normalized.endsWith("√©e") || 
               nextToken.normalized.endsWith("√©s") || 
               nextToken.normalized.endsWith("√©es"))) {
            
            return { 
              type: "verb", 
              subtype: "auxiliaire (voix passive)", 
              confidence: "high",
              isAuxiliary: true,
              role: "auxiliaire passive"
            };
          }
        }
      }
      
      return null;
    }
    
    // Analyse par terminaison (suffixes)
    function analyzeByEnding(word) {
      // 1. Terminaisons nominales
      const nominalEndings = [
        { suffix: "tion", type: "noun", gender: "feminine" },
        { suffix: "sion", type: "noun", gender: "feminine" },
        { suffix: "t√©", type: "noun", gender: "feminine" },
        { suffix: "it√©", type: "noun", gender: "feminine" },
        { suffix: "isme", type: "noun", gender: "masculine" },
        { suffix: "age", type: "noun", gender: "masculine" },
        { suffix: "ment", type: "noun", gender: "masculine" },
        { suffix: "eur", type: "noun", gender: "masculine" },
        { suffix: "esse", type: "noun", gender: "feminine" },
        { suffix: "ette", type: "noun", gender: "feminine" },
        { suffix: "ie", type: "noun", gender: "feminine" },
        { suffix: "erie", type: "noun", gender: "feminine" },
        { suffix: "ance", type: "noun", gender: "feminine" },
        { suffix: "ence", type: "noun", gender: "feminine" },
        { suffix: "tude", type: "noun", gender: "feminine" },
        { suffix: "ade", type: "noun", gender: "feminine" },
        { suffix: "ure", type: "noun", gender: "feminine" },
        { suffix: "oir", type: "noun", gender: "masculine" },
        { suffix: "oire", type: "noun", gender: "feminine" }
      ];
      
      // 2. Terminaisons adjectivales
      const adjectivalEndings = [
        { suffix: "able", type: "adjective" },
        { suffix: "ible", type: "adjective" },
        { suffix: "eux", type: "adjective" },
        { suffix: "euse", type: "adjective" },
        { suffix: "if", type: "adjective" },
        { suffix: "ive", type: "adjective" },
        { suffix: "al", type: "adjective" },
        { suffix: "ale", type: "adjective" },
        { suffix: "el", type: "adjective" },
        { suffix: "elle", type: "adjective" },
        { suffix: "ique", type: "adjective" },
        { suffix: "aire", type: "adjective" },
        { suffix: "ien", type: "adjective" },
        { suffix: "ienne", type: "adjective" },
        { suffix: "ois", type: "adjective" },
        { suffix: "oise", type: "adjective" },
        { suffix: "ain", type: "adjective" },
        { suffix: "aine", type: "adjective" },
        { suffix: "ard", type: "adjective" },
        { suffix: "arde", type: "adjective" },
        { suffix: "ent", type: "adjective" },
        { suffix: "ente", type: "adjective" },
        { suffix: "escent", type: "adjective" },
        { suffix: "escente", type: "adjective" }
      ];
      
      // 3. Terminaisons adverbiales
      const adverbialEndings = [
        { suffix: "ment", type: "adverb" }
      ];
      
      // 4. Terminaisons verbales (infinitif)
      const verbalEndings = [
        { suffix: "er", type: "verb", subtype: "infinitif", group: 1 },
        { suffix: "ir", type: "verb", subtype: "infinitif", group: 2 },
        { suffix: "re", type: "verb", subtype: "infinitif", group: 3 },
        { suffix: "oir", type: "verb", subtype: "infinitif", group: 3 }
      ];
      
      // V√©rifier les terminaisons dans l'ordre: adjectival, nominal, adverbial, verbal
      // Car certaines terminaisons peuvent √™tre ambigu√´s (ex: "ment" peut √™tre nominal ou adverbial)
      
      // V√©rifier terminaisons adjectivales
      for (const ending of adjectivalEndings) {
        if (word.endsWith(ending.suffix) && word.length > ending.suffix.length + 1) {
          return { type: "adjective", subtype: "qualificatif", confidence: "medium" };
        }
      }
      
      // V√©rifier terminaisons nominales
      for (const ending of nominalEndings) {
        if (word.endsWith(ending.suffix) && word.length > ending.suffix.length + 1) {
          return { type: "noun", subtype: "commun", gender: ending.gender, confidence: "medium" };
        }
      }
      
      // V√©rifier terminaisons adverbiales (sauf celles qui sont aussi nominales)
      for (const ending of adverbialEndings) {
        // V√©rifier que ce n'est pas un nom se terminant par "ment"
        if (word.endsWith(ending.suffix) && word.length > ending.suffix.length + 2 &&
            !word.endsWith("ement") && !word.endsWith("issement")) {
          return { type: "adverb", confidence: "medium" };
        }
      }
      
      // V√©rifier terminaisons verbales
      for (const ending of verbalEndings) {
        // √âviter les faux positifs (noms se terminant par -er comme "dossier")
        const exceptions = ["dossier", "cahier", "papier", "tablier", "pilier", "escalier", "m√©tier"];
        if (word.endsWith(ending.suffix) && word.length > ending.suffix.length + 1 &&
            !exceptions.includes(word)) {
          return { 
            type: "verb", 
            subtype: ending.subtype, 
            group: ending.group,
            infinitive: word,
            confidence: "medium" 
          };
        }
      }
      
      return null;
    }
    
    // D√©duire la forme verbale √† partir de la terminaison
    function deduceVerbForm(word) {
      // Terminaisons du pr√©sent de l'indicatif
      const presentEndings = {
        firstGroup: {
          singular: ["e", "es", "e"],
          plural: ["ons", "ez", "ent"]
        },
        secondGroup: {
          singular: ["is", "is", "it"],
          plural: ["issons", "issez", "issent"]
        }
      };
      
      // V√©rifier les terminaisons du premier groupe (-er)
      // Singulier
      for (let i = 0; i < presentEndings.firstGroup.singular.length; i++) {
        const ending = presentEndings.firstGroup.singular[i];
        if (word.endsWith(ending) && word.length > ending.length + 1) {
          const stem = word.slice(0, word.length - ending.length);
          return {
            isVerb: true,
            tense: "indicatif pr√©sent",
            person: i + 1,
            number: "singular",
            infinitive: stem + "er",
            group: 1
          };
        }
      }
      
      // Pluriel
      for (let i = 0; i < presentEndings.firstGroup.plural.length; i++) {
        const ending = presentEndings.firstGroup.plural[i];
        if (word.endsWith(ending) && word.length > ending.length + 1) {
          const stem = word.slice(0, word.length - ending.length);
          return {
            isVerb: true,
            tense: "indicatif pr√©sent",
            person: i + 1,
            number: "plural",
            infinitive: stem + "er",
            group: 1
          };
        }
      }
      
      // V√©rifier les terminaisons du deuxi√®me groupe (-ir)
      // Singulier
      for (let i = 0; i < presentEndings.secondGroup.singular.length; i++) {
        const ending = presentEndings.secondGroup.singular[i];
        if (word.endsWith(ending) && word.length > ending.length + 1) {
          const stem = word.slice(0, word.length - ending.length);
          return {
            isVerb: true,
            tense: "indicatif pr√©sent",
            person: i + 1,
            number: "singular",
            infinitive: stem + "ir",
            group: 2
          };
        }
      }
      
      // Pluriel
      for (let i = 0; i < presentEndings.secondGroup.plural.length; i++) {
        const ending = presentEndings.secondGroup.plural[i];
        if (word.endsWith(ending) && word.length > ending.length + 1) {
          // On retire "-iss" pour obtenir le radical
          const stem = word.slice(0, word.length - ending.length);
          return {
            isVerb: true,
            tense: "indicatif pr√©sent",
            person: i + 1,
            number: "plural",
            infinitive: stem + "ir",
            group: 2
          };
        }
      }
      
      // Terminaisons pour le participe pr√©sent (-ant)
      if (word.endsWith("ant") && word.length > 4) {
        const stem = word.slice(0, word.length - 3);
        return {
          isVerb: true,
          tense: "participe pr√©sent",
          infinitive: stem + "er", // Hypoth√®se
          group: 1 // Hypoth√®se
        };
      }
      
      // Terminaisons pour le participe pass√© (-√©, -√©e, -√©s, -√©es)
      if ((word.endsWith("√©") || word.endsWith("√©e") || word.endsWith("√©s") || word.endsWith("√©es")) && word.length > 2) {
        const stem = word.slice(0, word.length - (word.endsWith("√©") ? 1 : (word.endsWith("√©s") || word.endsWith("√©e") ? 2 : 3)));
        return {
          isVerb: true,
          tense: "participe pass√©",
          infinitive: stem + "er",
          group: 1,
          isPastParticiple: true
        };
      }
      
      return { isVerb: false };
    }
    
    // Fonction pour analyser le texte en recherchant les verbes pronominaux
    function detectVerbPronominal(tokens, startIndex) {
      if (startIndex >= tokens.length - 1) return null;
      
      const currentToken = tokens[startIndex];
      const nextToken = tokens[startIndex + 1];
      
      // V√©rifier si le token actuel est un pronom r√©fl√©chi
      if (currentToken.type === "pronoun" && 
          (currentToken.subtype === "r√©fl√©chi" || currentToken.normalized === "se" || currentToken.normalized === "s'")) {
        
        // V√©rifier si le token suivant est un verbe ou peut √™tre analys√© comme un verbe
        if (nextToken.type === "verb" || (nextToken.type === "adjective" && nextToken.normalized.endsWith("ent"))) {
          // Cr√©er une structure de verbe pronominal
          return {
            start: startIndex,
            end: startIndex + 1,
            type: "verb_pronominal",
            components: [
              { ...currentToken, role: "reflexive_pronoun" },
              { ...nextToken, type: "verb", role: "verb_component", subtype: "indicatif pr√©sent" }
            ]
          };
        }
      }
      
      return null;
    }
    
    // D√©tection de voix passive
    function detectPassiveVoice(tokens, startIndex) {
      // Il faut au moins 3 tokens pour une voix passive minimale: sujet + √™tre + participe pass√©
      if (startIndex + 2 >= tokens.length) return null;
      
      // V√©rifier si on a un auxiliaire √™tre suivi d'un participe pass√©
      let auxIndex = -1;
      let participleIndex = -1;
      
      // Rechercher l'auxiliaire √™tre
      for (let i = startIndex; i < tokens.length - 1; i++) {
        if (tokens[i].type === "verb" && tokens[i].isAuxiliary && 
            tokens[i].infinitive === "√™tre") {
          auxIndex = i;
          
          // Rechercher le participe pass√© apr√®s l'auxiliaire
          for (let j = i + 1; j < tokens.length; j++) {
            if (tokens[j].type === "verb" && tokens[j].isPastParticiple) {
              participleIndex = j;
              break;
            }
          }
          
          break;
        }
      }
      
      if (auxIndex !== -1 && participleIndex !== -1) {
        // Rechercher un potentiel compl√©ment d'agent introduit par "par" ou "de"
        let agentIndex = -1;
        let prepositionIndex = -1;
        
        for (let i = participleIndex + 1; i < tokens.length; i++) {
          if (tokens[i].type === "preposition" && 
              frenchLexicon.agentPrepositions.includes(tokens[i].normalized)) {
            prepositionIndex = i;
            
            // Chercher le compl√©ment d'agent apr√®s la pr√©position
            if (i + 1 < tokens.length && 
                (tokens[i+1].type === "noun" || tokens[i+1].type === "pronoun")) {
              agentIndex = i + 1;
              break;
            }
          }
        }
        
        // Structure de voix passive trouv√©e
        return {
          type: "passive_voice",
          auxiliaryIndex: auxIndex,
          participleIndex: participleIndex,
          prepositionIndex: prepositionIndex !== -1 ? prepositionIndex : null,
          agentIndex: agentIndex !== -1 ? agentIndex : null,
          // Le sujet est g√©n√©ralement avant l'auxiliaire
          subjectIndices: findSubjectBeforeIndex(tokens, auxIndex)
        };
      }
      
      return null;
    }
    
    // Trouver le sujet avant un certain indice
    function findSubjectBeforeIndex(tokens, endIndex) {
      // Le sujet peut √™tre un groupe nominal ou un pronom
      const subjectIndices = [];
      
      for (let i = 0; i < endIndex; i++) {
        // Si c'est un pronom sujet
        if (tokens[i].type === "pronoun" && tokens[i].subtype === "personnel sujet") {
          subjectIndices.push(i);
        }
        // Si c'est un nom pr√©c√©d√© d'un d√©terminant (groupe nominal)
        else if (tokens[i].type === "noun" && i > 0 && tokens[i-1].type === "determiner") {
          subjectIndices.push(i-1, i); // Inclure le d√©terminant et le nom
          
          // Inclure aussi les adjectifs qui qualifient ce nom
          let j = i + 1;
          while (j < endIndex && tokens[j].type === "adjective") {
            subjectIndices.push(j);
            j++;
          }
        }
      }
      
      return subjectIndices;
    }
    
    // Extraction du radical verbal (pour les verbes pronominaux)
    function extractVerbStem(word) {
      // Enlever les terminaisons communes pour trouver le radical
      if (word.endsWith("ent")) return word.slice(0, word.length - 3);
      if (word.endsWith("ez")) return word.slice(0, word.length - 2);
      if (word.endsWith("ons")) return word.slice(0, word.length - 3);
      if (word.endsWith("e") || word.endsWith("es")) return word.slice(0, word.length - 1);
      
      return word; // Par d√©faut
    }
    
    // Analyse syntaxique et r√©solution des ambigu√Øt√©s
    function syntacticAnalysis(tokens) {
      const analyzed = [...tokens];
      
      // Parcourir les tokens pour r√©soudre les ambigu√Øt√©s
      for (let i = 0; i < analyzed.length; i++) {
        if (analyzed[i].type === "punctuation") continue;
        
        // R√©soudre les ambigu√Øt√©s articles/pronoms ("le", "la", "les")
        if (analyzed[i].normalized === "le" || analyzed[i].normalized === "la" || analyzed[i].normalized === "les") {
          // Si suivi d'un nom ou adjectif, c'est un article
          if (i < analyzed.length - 1 && 
              (analyzed[i+1].type === "noun" || analyzed[i+1].type === "adjective")) {
            analyzed[i].type = "determiner";
            analyzed[i].subtype = "article d√©fini";
          }
          // Sinon c'est probablement un pronom
          else {
            analyzed[i].type = "pronoun";
            analyzed[i].subtype = "personnel compl√©ment";
          }
        }
        
        // R√©soudre les ambigu√Øt√©s pour les pronoms r√©fl√©chis dans les verbes pronominaux
        if (analyzed[i].normalized === "se" || analyzed[i].normalized === "s'") {
          // Si suivi d'un mot qui pourrait √™tre un verbe
          if (i < analyzed.length - 1) {
            const nextToken = analyzed[i+1];
            // Si d√©j√† identifi√© comme verbe ou si a une terminaison verbale
            if (nextToken.type === "verb" || 
                (nextToken.normalized.endsWith("e") || nextToken.normalized.endsWith("es") || 
                 nextToken.normalized.endsWith("ent"))) {
              
              analyzed[i].type = "pronoun";
              analyzed[i].subtype = "r√©fl√©chi";
              analyzed[i].role = "pronom r√©fl√©chi (verbe pronominal)";
              
              // Assurer que le token suivant est identifi√© comme verbe
              if (nextToken.type !== "verb") {
                analyzed[i+1].type = "verb";
                analyzed[i+1].subtype = "indicatif pr√©sent";
                analyzed[i+1].role = "composante verbale (verbe pronominal)";
              }
            }
          }
        }
        
        // Correction pour les adjectifs qui suivent un d√©terminant et pr√©c√®dent un nom
        if (analyzed[i].type === "adjective" && i > 0 && i < analyzed.length - 1) {
          const prevToken = analyzed[i-1];
          const nextToken = analyzed[i+1];
          
          if (prevToken.type === "determiner" && nextToken.type === "noun") {
            analyzed[i].position = "avant le nom";
            analyzed[i].pattern = "d√©terminant + adjectif + nom";
          }
        }
        
        // Correction pour les mots qui ne devraient pas √™tre des adjectifs apr√®s un d√©terminant
        if (analyzed[i].type === "adjective" && i > 0) {
          const prevToken = analyzed[i-1];
          
          if (prevToken.type === "determiner" && 
              !frenchLexicon.commonAdjectives.includes(analyzed[i].normalized) && 
              i === analyzed.length - 1) {
            // Si c'est le dernier mot apr√®s un d√©terminant et pas un adjectif reconnu
            analyzed[i].type = "noun";
            analyzed[i].subtype = "commun";
            delete analyzed[i].position;
          }
        }
        
        // Am√©lioration de la d√©tection des auxiliaires pour la voix passive
        if (analyzed[i].type === "verb" && 
            (analyzed[i].infinitive === "√™tre" || 
             analyzed[i].normalized === "est" || 
             analyzed[i].normalized === "sont")) {
          
          // V√©rifier si suivi d'un participe pass√©
          if (i < analyzed.length - 1) {
            const nextToken = analyzed[i+1];
            if (nextToken.type === "verb" && 
                (nextToken.subtype === "participe pass√©" || nextToken.isPastParticiple)) {
              analyzed[i].isAuxiliary = true;
              analyzed[i].role = "auxiliaire (voix passive)";
            }
          }
        }
      }
      
      return analyzed;
    }
    
    // D√©tection des structures grammaticales sp√©ciales
    function detectSpecialStructures(tokens) {
      const result = [...tokens];
      let i = 0;
      
      while (i < result.length) {
        // D√©tecter les verbes pronominaux
        const verbPronominal = detectVerbPronominal(result, i);
        if (verbPronominal) {
          // Marquer le pronom r√©fl√©chi
          result[i].role = "pronom r√©fl√©chi";
          result[i].verbPronominalPart = true;
          
          // Marquer le verbe
          result[i+1].type = "verb";
          result[i+1].subtype = "indicatif pr√©sent";
          result[i+1].verbPronominalPart = true;
          result[i+1].role = "composante verbale";
          
          // Sauter le token suivant qui fait partie du verbe pronominal
          i += 2;
          continue;
        }
        
        // D√©tecter et corriger les "il y a" (locution verbale)
        if (i < result.length - 2 && 
            result[i].normalized === "il" && 
            result[i+1].normalized === "y" && 
            result[i+2].normalized === "a") {
          
          result[i].role = "composante de locution verbale";
          result[i+1].role = "composante de locution verbale";
          result[i+2].role = "composante de locution verbale";
          
          i += 3;
          continue;
        }
        
        i++;
      }
      
      // D√©tection de voix passive dans l'ensemble de la phrase
      const passiveVoice = detectPassiveVoice(result, 0);
      if (passiveVoice) {
        // Marquer l'auxiliaire
        result[passiveVoice.auxiliaryIndex].role = "auxiliaire (voix passive)";
        
        // Marquer le participe pass√©
        result[passiveVoice.participleIndex].role = "participe pass√© (voix passive)";
        
        // Marquer le compl√©ment d'agent si pr√©sent
        if (passiveVoice.prepositionIndex !== null) {
          result[passiveVoice.prepositionIndex].role = "pr√©position (compl√©ment d'agent)";
        }
        
        if (passiveVoice.agentIndex !== null) {
          result[passiveVoice.agentIndex].role = "compl√©ment d'agent";
          result[passiveVoice.agentIndex].isAgent = true;
        }
        
        // Marquer le sujet
        passiveVoice.subjectIndices.forEach(index => {
          result[index].isPassiveSubject = true;
          if (result[index].type === "noun") {
            result[index].role = "sujet (patient)";
          } else if (result[index].type === "determiner") {
            result[index].role = "d√©terminant du sujet";
          }
        });
      }
      
      return result;
    }
    
    // Identification des sujets, verbes et compl√©ments dans la phrase
    function identifySentenceComponents(tokens) {
      const result = [...tokens];
      let mainVerb = null;
      let mainVerbIndex = -1;
      
      // Premi√®re √©tape: identifier le verbe principal
      for (let i = 0; i < result.length; i++) {
        if (result[i].type === "verb" && !result[i].isAuxiliary && 
            !result[i].isPastParticiple && !result[i].verbPronominalPart) {
          mainVerb = result[i];
          mainVerbIndex = i;
          mainVerb.role = "verbe principal";
          break;
        }
      }
      
      // Si pas de verbe principal trouv√©, chercher un verbe pronominal
      if (mainVerbIndex === -1) {
        for (let i = 0; i < result.length - 1; i++) {
          if (result[i].type === "pronoun" && result[i].subtype === "r√©fl√©chi" &&
              result[i+1].type === "verb") {
            mainVerb = result[i+1];
            mainVerbIndex = i+1;
            mainVerb.role = "verbe principal (pronominal)";
            result[i].role = "pronom r√©fl√©chi du verbe principal";
            break;
          }
        }
      }
      
      // Si toujours pas de verbe principal, chercher un auxiliaire + participe pass√©
      if (mainVerbIndex === -1) {
        for (let i = 0; i < result.length - 1; i++) {
          if (result[i].type === "verb" && result[i].isAuxiliary &&
              i+1 < result.length && result[i+1].type === "verb" && result[i+1].isPastParticiple) {
            mainVerb = result[i+1];
            mainVerbIndex = i+1;
            mainVerb.role = "participe pass√© du verbe principal";
            result[i].role = "auxiliaire du verbe principal";
            break;
          }
        }
      }
      
      // Si on a trouv√© un verbe principal, chercher son sujet et ses compl√©ments
      if (mainVerbIndex !== -1) {
        // Chercher le sujet (avant le verbe principal)
        let subjectFound = false;
        
        // Cas 1: Pronom personnel sujet juste avant le verbe
        if (mainVerbIndex > 0 && 
            result[mainVerbIndex-1].type === "pronoun" && 
            result[mainVerbIndex-1].subtype === "personnel sujet") {
          result[mainVerbIndex-1].role = "sujet";
          result[mainVerbIndex-1].isSubject = true;
          subjectFound = true;
        }
        // Cas 2: Chercher un groupe nominal (d√©terminant + nom)
        else {
          for (let i = 0; i < mainVerbIndex; i++) {
            if (result[i].type === "noun" && i > 0 && result[i-1].type === "determiner") {
              result[i].role = "sujet";
              result[i].isSubject = true;
              result[i-1].role = "d√©terminant du sujet";
              
              // V√©rifier s'il y a des adjectifs apr√®s le nom
              let j = i + 1;
              while (j < mainVerbIndex && result[j].type === "adjective") {
                result[j].role = "adjectif du sujet";
                j++;
              }
              
              subjectFound = true;
              break;
            }
          }
        }
        
        // Si on n'a pas trouv√© de sujet standard, v√©rifier s'il s'agit d'une voix passive
        if (!subjectFound) {
          for (let i = 0; i < result.length; i++) {
            if (result[i].isPassiveSubject) {
              subjectFound = true;
              break;
            }
          }
        }
        
        // Chercher un compl√©ment d'objet direct apr√®s le verbe
        let objectFound = false;
        
        // Cas 1: Pronom personnel compl√©ment avant le verbe
        for (let i = 0; i < mainVerbIndex; i++) {
          if (result[i].type === "pronoun" && result[i].subtype === "personnel compl√©ment") {
            result[i].role = "compl√©ment d'objet direct";
            result[i].isObject = true;
            objectFound = true;
            break;
          }
        }
        
        // Cas 2: Groupe nominal apr√®s le verbe
        if (!objectFound) {
          for (let i = mainVerbIndex + 1; i < result.length; i++) {
            if (result[i].type === "noun" && i > 0 && result[i-1].type === "determiner") {
              // V√©rifier qu'il n'est pas d√©j√† identifi√© comme agent dans une voix passive
              if (!result[i].isAgent) {
                result[i].role = "compl√©ment d'objet direct";
                result[i].isObject = true;
                result[i-1].role = "d√©terminant du COD";
                
                // V√©rifier s'il y a des adjectifs apr√®s le nom
                let j = i + 1;
                while (j < result.length && result[j].type === "adjective") {
                  result[j].role = "adjectif du COD";
                  j++;
                }
                
                objectFound = true;
                break;
              }
            }
          }
        }
      }
      
      return result;
    }
    
    // Regrouper les r√©sultats par cat√©gorie grammaticale
    function categorizeResults(analyzedTokens) {
      const categories = {
        pronoun: [],
        verb: [],
        noun: [],
        adjective: [],
        determiner: [],
        adverb: [],
        preposition: [],
        conjunction: [],
        negation: [],
        interjection: []
      };
      
      analyzedTokens.forEach(token => {
        if (token.type === "punctuation") return;
        
        if (token.type in categories) {
          // √âviter les doublons dans chaque cat√©gorie
          const exists = categories[token.type].some(item => 
            item.normalized === token.normalized
          );
          
          if (!exists) {
            categories[token.type].push(token);
          }
        }
      });
      
      return categories;
    }
    
    // Analyser la structure de la phrase
    function analyzeSentenceStructure(analyzedTokens) {
      // D√©tecter si la phrase est active ou passive
      let isPassive = false;
      let mainVerb = null;
      let subject = null;
      let object = null;
      let agent = null;
      
      // Trouver le sujet, le verbe principal et l'objet
      analyzedTokens.forEach(token => {
        if (token.isSubject) subject = token;
        if (token.role === "verbe principal" || token.role === "participe pass√© du verbe principal") mainVerb = token;
        if (token.isObject) object = token;
        if (token.isAgent) agent = token;
        if (token.role === "auxiliaire (voix passive)") isPassive = true;
      });
      
      // D√©terminer le type de phrase
      let sentenceType = "d√©clarative";
      if (analyzedTokens.length > 0 && analyzedTokens[analyzedTokens.length - 1].original === "?") {
        sentenceType = "interrogative";
      } else if (analyzedTokens.length > 0 && analyzedTokens[analyzedTokens.length - 1].original === "!") {
        sentenceType = "exclamative";
      }
      
      // D√©terminer le type de construction (active, passive, etc.)
      let constructionType = isPassive ? "passive" : "active";
      
      return {
        type: sentenceType,
        construction: constructionType,
        subject: subject ? subject.original : "non identifi√©",
        mainVerb: mainVerb ? mainVerb.original : "non identifi√©", 
        object: object ? object.original : (isPassive ? "sujet de la voix passive" : "non identifi√©"),
        agent: agent ? agent.original : "non identifi√©"
      };
    }
    
    // G√©n√©rer le HTML pour afficher une cat√©gorie grammaticale
    function generateCategoryHTML(category, items) {
      if (!items || items.length === 0) return '';
      
      let html = `
        <div class="category-header">
          <div class="category-badge ${category}-badge">${categoryNames[category]}</div>
          <div class="category-description">${categoryDescriptions[category]}</div>
        </div>
        <div class="category-content">
      `;
      
      items.forEach(item => {
        let displayText = item.original;
        
        // Ajouter des informations pertinentes selon la cat√©gorie
        if (category === "verb") {
          if (item.infinitive) {
            displayText = `${item.original}`;
            if (item.infinitive !== item.original.toLowerCase()) {
              displayText += ` [${item.infinitive}`;
              if (item.subtype && item.subtype !== "infinitif") {
                displayText += ` (${item.subtype})`;
              }
              displayText += `]`;
            }
          }
        } 
        else if (item.role) {
          displayText = `${item.original} [${item.role}]`;
        }
        
        html += `<span class="word-tag ${category} tooltip">${displayText}<span class="tooltip-text">${categoryNames[category]}${item.subtype ? ` ${item.subtype}` : ''}</span></span>`;
      });
      
      html += `
        </div>
      `;
      
      return html;
    }
    
    // Formatter le texte analys√© en HTML avec des √©tiquettes de couleur
    function formatAnalyzedText(analyzedTokens) {
      let html = '';
      
      analyzedTokens.forEach(token => {
        if (token.type === "punctuation") {
          html += token.original;
        } else {
          let cssClasses = `word-tag ${token.type} tooltip`;
          
          // Ajouter des classes sp√©ciales pour les sujets et objets
          if (token.isSubject || token.isPassiveSubject) cssClasses += ' subject';
          if (token.isObject) cssClasses += ' object';
          
          const tooltipContent = `${categoryNames[token.type]}${token.subtype ? ` ${token.subtype}` : ''}${token.role ? `<br>R√¥le: ${token.role}` : ''}`;
          
          html += `<span class="${cssClasses}">${token.original}<span class="tooltip-text">${tooltipContent}</span></span> `;
        }
      });
      
      return html;
    }
    
    // G√©n√©rer le HTML pour afficher la structure de la phrase
    function generateStructureHTML(structure) {
      return `
        <div class="sentence-structure">
          <div class="structure-title">ANALYSE DE STRUCTURE</div>
          <div class="structure-item">
            <div class="structure-label">Type:</div>
            <div class="structure-value">Phrase ${structure.type}</div>
          </div>
          <div class="structure-item">
            <div class="structure-label">Construction:</div>
            <div class="structure-value">Voix ${structure.construction}</div>
          </div>
          <div class="structure-item">
            <div class="structure-label">Sujet:</div>
            <div class="structure-value">${structure.subject}</div>
          </div>
          <div class="structure-item">
            <div class="structure-label">Verbe:</div>
            <div class="structure-value">${structure.mainVerb}</div>
          </div>
          ${structure.construction === "passive" ? `
          <div class="structure-item">
            <div class="structure-label">Patient:</div>
            <div class="structure-value">${structure.subject}</div>
          </div>
          <div class="structure-item">
            <div class="structure-label">Agent:</div>
            <div class="structure-value">${structure.agent !== "non identifi√©" ? structure.agent : "non sp√©cifi√©"}</div>
          </div>
          ` : `
          <div class="structure-item">
            <div class="structure-label">Objet:</div>
            <div class="structure-value">${structure.object !== "non identifi√©" ? structure.object : "non sp√©cifi√©"}</div>
          </div>
          `}
        </div>
      `;
    }
    
    // Obtenir l'heure actuelle format√©e
    function getCurrentTime() {
      const now = new Date();
      let hours = now.getHours();
      let minutes = now.getMinutes();
      
      // Ajouter un 0 devant les chiffres < 10
      hours = hours < 10 ? '0' + hours : hours;
      minutes = minutes < 10 ? '0' + minutes : minutes;
      
      return `${hours}:${minutes}`;
    }
    
    // Ajouter un message utilisateur au chat
    function addUserMessage(text) {
      const chatContainer = document.getElementById('chatContainer');
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message user';
      messageDiv.innerHTML = `
        <div class="message-content">${text}</div>
        <div class="message-time">${getCurrentTime()}</div>
      `;
      
      chatContainer.appendChild(messageDiv);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }
    
    // Ajouter un indicateur de saisie
    function addTypingIndicator() {
      const chatContainer = document.getElementById('chatContainer');
      const typingDiv = document.createElement('div');
      typingDiv.className = 'typing-indicator';
      typingDiv.id = 'typingIndicator';
      typingDiv.innerHTML = `
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
      `;
      
      chatContainer.appendChild(typingDiv);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }
    
    // Supprimer l'indicateur de saisie
    function removeTypingIndicator() {
      const typingIndicator = document.getElementById('typingIndicator');
      if (typingIndicator) {
        typingIndicator.remove();
      }
    }
    
    // Ajouter un message bot au chat
    function addBotMessage(content) {
      removeTypingIndicator();
      
      const chatContainer = document.getElementById('chatContainer');
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message bot';
      messageDiv.innerHTML = `
        <div class="message-content">${content}</div>
        <div class="message-time">${getCurrentTime()}</div>
      `;
      
      chatContainer.appendChild(messageDiv);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }
    
    // Fonction principale pour analyser la phrase
    function analyzeSentence(text) {
      try {
        // Tokeniser le texte
        const tokens = tokenizeText(text);
        
        // Analyser la grammaire
        const analyzedTokens = analyzeGrammar(tokens);
        
        // Analyser la structure de la phrase
        const sentenceStructure = analyzeSentenceStructure(analyzedTokens);
        
        // Regrouper les r√©sultats par cat√©gorie
        const categorizedResults = categorizeResults(analyzedTokens);
        
        // Formater le texte analys√©
        const analyzedTextHtml = formatAnalyzedText(analyzedTokens);
        
        // Pr√©parer la r√©ponse
        let response = `Voici l'analyse de votre phrase:<br><br>${analyzedTextHtml}<br><br>`;
        
        // Ajouter la structure de la phrase
        response += generateStructureHTML(sentenceStructure);
        
        // Ajouter les cat√©gories grammaticales
        response += `<div class="category-list">`;
        
        // Ordre des cat√©gories
        const categoryOrder = ['pronoun', 'verb', 'noun', 'adjective', 'determiner', 'adverb', 'preposition', 'conjunction', 'negation', 'interjection'];
        
        categoryOrder.forEach(category => {
          const items = categorizedResults[category];
          if (items && items.length > 0) {
            response += generateCategoryHTML(category, items);
          }
        });
        
        response += `</div>`;
        
        return response;
      } catch (error) {
        console.error("Erreur lors de l'analyse:", error);
        return `Une erreur s'est produite lors de l'analyse: ${error.message}`;
      }
    }
    
    // Gestionnaire d'√©v√©nements
    document.addEventListener('DOMContentLoaded', function() {
      const userInput = document.getElementById('userInput');
      const sendButton = document.getElementById('sendButton');
      
      // Fonction pour envoyer le message
      function sendMessage() {
        const text = userInput.value.trim();
        if (!text) return;
        
        // Afficher le message de l'utilisateur
        addUserMessage(text);
        
        // Effacer l'entr√©e
        userInput.value = '';
        
        // Afficher l'indicateur de saisie
        addTypingIndicator();
        
        // Analyser la phrase apr√®s un court d√©lai pour montrer l'animation
        setTimeout(function() {
          const response = analyzeSentence(text);
          addBotMessage(response);
        }, 1000);
      }
      
      // √âcouter le clic sur le bouton d'envoi
      sendButton.addEventListener('click', sendMessage);
      
      // √âcouter la touche Entr√©e dans l'input
      userInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          sendMessage();
        }
      });
      
      // Focus sur l'input au chargement
      userInput.focus();
    });
  </script>
</body>
</html>
